# Chapter11. API 리팩터링

> 결국 책임 소재를 프로그램의 어디에 배정하냐의 문제로 귀결된다. 답을 찾기가 쉽지 않으며 항상 정답이 있는 것도 아니다.

## 후기
**11.1 질의 함수와 변경 함수 분리하기** <br/>
하나의 함수안에 질의 함수(읽기 함수)와 변경 함수가 같이 있을 때, 이를 분리함으로써 책임이 명확해지고, 디버깅/테스트 하기 쉬워지는 효과를 경험해 볼 수 있어서 좋았다.

<br/>

**11.5, 11.6 매개변수 ↔️ 질의 함수 바꾸기** / **11.9, 11.10 함수 ↔️ 명령 바꾸기** <br/>
상반된 리팩터링을 비교하면서 결국 정답이 있는 게 아니고 경험에 의거하여 상황에 따라 책임 소재를 어디에 배정할 것인지 선택해야 한다는 걸 배울 수 있었다. 
또한, 명령의 의미가 두 개로 나눠진다는 것도 알 수 있어 좋았다. 예전에 헤드 퍼스트 디자인 패턴을 학습했을 때 Command Pattern 예시가 이해 안 되었었다. 
그런데 이번 챕터 학습 후 다시 보니 이해도가 전보다 높아진 걸 알 수 있어 좋았다.
<br/>

**명령(Command) 의미**
- Command Pattern: 이때 명령은 요청을 캡슐화한 객체에게 위임하여 실행 (이번 챕터에서 설명하는 명령에 해당)
- CommandAndQuerySeparation: 명령-질의 분리 원칙에서도 명령이 등장하는데, 이때 명령은 객체의 겉보기 상태를 변경(update, insert, delete)하는 메서드를 가르킨다

<br/>

**참고. 헤드 퍼스트 디자인 패턴 - 명령 패턴 (Command Pattern)** <br/>

<img src="https://github.com/ljw1126/user-content/blob/master/refactoring2/ch11/%EB%AA%85%EB%A0%B9%20%ED%8C%A8%ED%84%B41.png?raw=true"/>

<img src="https://github.com/ljw1126/user-content/blob/master/refactoring2/ch11/%EB%AA%85%EB%A0%B9%20%ED%8C%A8%ED%84%B42.png?raw=true"/>

<img src="https://github.com/ljw1126/user-content/blob/master/refactoring2/ch11/%EB%AA%85%EB%A0%B9%20%ED%8C%A8%ED%84%B43.png?raw=true"/>

<img src="https://github.com/ljw1126/user-content/blob/master/refactoring2/ch11/%EB%AA%85%EB%A0%B9%20%ED%8C%A8%ED%84%B44.png?raw=true">

- 고객이 직접 Cook(요리사)를 알고, 주문(Order)의 세부 내역을 아는게 이해가 안 되었다.
- 다시보니 커맨드 인터페이스(Order) 구현체 생성 책임을 보기 편하게 한 곳에 모았구나라는 걸 알 수 있었다
  - 고객이 order(주문)를 할때 cook(요리사)한테 어떻게 조리할지 알고 싶지 않다면 구현에 대한 책임을 다른 곳에 위임했으면 된다.
  - 요청을 캡슐화하여 호출하는게 명령 패턴의 설명 목적이었다.

<br/>

**🤖참조 투명성과 일급 함수** <br/>

**1. 참조 투명성 (Referential Transparency)**
- 같은 입력에 대해 항상 같은 출력을 반환하는 **순수 함수(Pure Function)** 의 특성
- 함수의 결과가 외부 상태나 부수 효과(Side Effect)에 영향을 받지 않음
- 즉, 함수를 실행할 때 외부 상태를 변경하지 않으며, 함수 호출을 해당 반환 값으로 치환해도 프로그램의 동작이 동일

```java
// ✨언제나 같은 입력에 같은 결과값 반환(=참조 투명함)
int add(int a, int b) {
    return a + b;  // 동일한 입력에 대해 항상 동일한 출력 반환
}


// 💩외부 상태에 의존해 참조 투명하지 않다
int randomValue = new Random().nextInt(10);

int addRandom(int a) {
  return a + randomValue;  // 실행할 때마다 다른 결과 반환 가능
}
```
<br/>

**2. 일급 함수 (First-Class Function)**
- 함수를 값처럼 다룰 수 있는 특성
- 즉, 함수를 변수에 할당, 함수의 매개변수로 전달, 반환 값으로 사용 가능 → **일급 함수 특징**
```java
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        Function<Integer, Integer> square = x -> x * x;  // 함수 할당
        System.out.println(square.apply(5)); // 25

        Function<Function<Integer, Integer>, Integer> applyFunc = f -> f.apply(10);
        System.out.println(applyFunc.apply(square)); // 100
    }
}
```

---
## 목차
- [11.1 질의 함수와 변경 함수 분리하기](#111-질의-함수와-변경-함수-분리하기-)
- [11.2 함수 매개변수화하기](#112-함수-매개변수화하기)
- [11.3 플래그 인수 제거하기](#113-플래그-인수-제거하기)
- [11.4 객체 통째로 넘기기](#114-객체-통째로-넘기기)
- [11.5 매개변수를 질의 함수로 바꾸기](#115-매개변수를-질의-함수로-바꾸기)
- [11.6 질의 함수를 매개변수로 바꾸기](#116-질의-함수를-매개변수로-바꾸기)
- [11.7 세터 제거하기](#117-세터-제거하기)
- [11.8 생성자를 팩터리 함수로 바꾸기](#118-생성자를-팩터리-함수로-바꾸기)
- [11.9 함수를 명령으로 바꾸기](#119-함수를-명령으로-바꾸기)
- [11.10 명령을 함수로 바꾸기](#1110-명령을-함수로-바꾸기-)
- [11.11 수정된 값 변환하기](#1111-수정된-값-변환하기)
- [11.12 오류 코드를 예외로 바꾸기](#1112-오류-코드를-예외로-바꾸기)
- [11.13 예외를 사전확인으로 바꾸기](#1113-예외를-사전확인으로-바꾸기)


<br/>

### 11.1 질의 함수와 변경 함수 분리하기 
- 카탈로그: [Separate Query from Modifier](https://refactoring.com/catalog/separateQueryFromModifier.html)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch11/ex1)
  - [테스트](../src/test/java/com/example/refactoring2/ch11/ex1)

<br/>

**배경**
- 우리는 외부에서 관찰할 수 있는 `겉보기 부수효과(observable side effect)`가 전혀 없이 값을 반환해주는 함수를 추구해야 한다
- 이런 함수는 어느 때건 원하는 만큼 호출해도 아무 문제가 없다
- 호출하는 문장의 위치를 호출하는 함수 안 어디로든 옮겨도 되며 테스트하기도 쉽다
  - 한마디로, 이용할 때 신경 쓸 거리가 매우 적다
- 겉보기 부수효과가 있는 함수와 없는 함수를 명확히 구분하는 것이 좋다
- 이를 위한 한 가지 방법은 `'질의 함수(읽기 함수)는 모두 부수효과가 없어야 한다'`는 규칙을 따르는 것이다
  - 이를 `명령-질의 분리(command-query-separation)`라 한다
    - 저자는 이 규칙을 100% 신봉하기보다, 되도록 따르려 노력하고 있으며 그 동안 효과도 톡톡히 봤다고 말한다
- 저자는 **값을 반환하면서 부수효과도 있는 함수를 발견하면 상태를 변경하는 부분과 질의하는 부분을 분리하려 시도한다**고 말한다 
  - 무조건이다✨
<br/>

**절차**
- 대상 함수를 복제하고 질의 목적에 충실한 이름을 짓는다
  - 함수 내부를 살펴 무엇을 반환하는지 찾는다
  - 어떤 변수의 값을 반환한다면 그 변수 이름이 훌륭한 단초가 될 것이다
- 새 질의 함수에서 부수효과를 모두 제거한다
- 정적 검사를 수행한다
- 원래 함수(변경 함수를 호출하는 곳을 모두 찾아낸다
  - 호출하는 곳에서 반환 값을 사용한다면 질의 함수를 호출하도록 바꾸고, 원래 함수를 호출하는 코드를 바로 아래 줄에 새로 추가한다
  - 하나 수정할 때마다 테스트한다
- 원래 함수에서 질의 관련 코드를 제거한다
- 테스트한다
<br/>

**💩before**
```java
public class MiscreantVillain {

  private Alarm alarm;

  public MiscreantVillain(Alarm alarm) {
    this.alarm = alarm;
  }

  public String alertForMiscreant(String[] people) {
    for (String p : people) {
      if (p.equals("조커")) {
        alarm.setOfAlarms(); // 💩
        return "조커";
      }

      if (p.equals("사루만")) {
        alarm.setOfAlarms(); // 💩
        return "사루만";
      }
    }

    return "";
  }
}
```
<br/>

**✨after**
```java
public class MiscreantVillain {

  private Alarm alarm;

  public MiscreantVillain(Alarm alarm) {
    this.alarm = alarm;
  }

  public void alertForMiscreant(String[] people) {
    if (!findMiscreant(people).isBlank()) {
      alarm.setOffAlarms();
    }
  }

  private String findMiscreant(String[] people) {
    for (String p : people) {
      if (p.equals("조커")) {
        return "조커";
      }

      if (p.equals("사루만")) {
        return "사루만";
      }
    }

    return "";
  }
}
```
<br/>




### 11.2 함수 매개변수화하기
- 카탈로그: [Parameterize Function](https://refactoring.com/catalog/parameterizeFunction.html)
- 1판에서의 이름: 메서드를 매개변수로 전환
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch11/ex2)
  - [테스트](../src/test/java/com/example/refactoring2/ch11/ex2)

<br/>

**배경**
- 다른 값만 매개변수로 받아 처리하는 함수 하나로 합쳐서 중복을 없앨 수 있다
  - 이렇게 하면 매개변수 값만 바꿔서 여러 곳에서 쓸 수 있으니 함수의 유용성이 커진다
<br/>

**절차**
- 비슷한 함수 중 하나를 선택한다
- 함수 선언 바꾸기로 리터럴들을 매개변수로 추가한다
- 이 함수를 호출하는 곳 모두에 적절한 리터럴 값을 추가한다
- 테스트한다 
- 매개변수로 받은 값을 사용하도록 함수 본문을 수정한다. 하나 수정할 때마다 테스트한다
- 비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정한다
  - 하나 수정할 때마다 테스트한다
  - 매개변수화된 함수가 대체할 비슷한 함수와 다르게 동작한다면, 그 비슷한 함수의 동작도 처리할 수 있도록 본문 코드를 적절히 수정한 후 진행한다

<br/>

**💩before**
```java
public class SalaryMan {
  private Salary salary;

  public SalaryMan(Salary salary) {
    this.salary = salary;
  }

  public void tenPercentRaise() {
    this.salary = this.salary.multiply(1.1);
  }

  public void fivePercentRaise() {
    this.salary = this.salary.multiply(1.05);
  }
  
  // equals, hashCode
}


public class Salary {
  private final BigDecimal amount;

  private Salary(BigDecimal amount) {
    this.amount = amount;
  }

  public static Salary wons(long amount) {
    return new Salary(halfUp(BigDecimal.valueOf(amount)));
  }

  public static Salary wons(double amount) {
    return new Salary(halfUp(BigDecimal.valueOf(amount)));
  }

  private static BigDecimal halfUp(BigDecimal amount) {
    return amount.setScale(2); // ?
  }

  public Salary multiply(double percentage) {
    return new Salary(halfUp(this.amount.multiply(BigDecimal.valueOf(percentage))));
  }

  // equals, hashCode
}
```
<br/>

**✨after**
```java
public class SalaryMan {
  private Salary salary;

  public SalaryMan(Salary salary) {
    this.salary = salary;
  }

  public void raise(double factor) {
    this.salary = this.salary.multiply(1 + factor);
  }

  // equals, hashCode
}
```
<br/>


**💩before**
```java
public class Charge {

  public void baseCharge(long usage) {
    if (usage < 0L) return usd(0.0);

    double amount = bottomBand(usage) * 0.03 + middleBand(usage) * 0.05 + topBand(usage) * 0.07;

    return usd(amount);
  }

  private String usd(double value) {
    return value + " USD";
  }

  private long bottomBand(long usage) {
    return Math.min(usage, 100);
  }

  private long middleBand(long usage) {
    return usage > 100 ? Math.min(usage, 200) - 100 : 0;
  }

  private double topBand(long usage) {
      return (usage > 200) ? (usage - 200) : 0;
  }
}
```

**✨after**
```java
public class Charge {

  public String baseCharge(long usage) {
    if (usage < 0L) return usd(0.0);

    double amount =
        withinBand(usage, 0, 100) * 0.03
            + withinBand(usage, 100, 200) * 0.05
            + withinBand(usage, 200, Long.MAX_VALUE) * 0.07;

    return usd(amount);
  }

  private String usd(double value) {
    return value + " USD";
  }

  private long withinBand(long usage, long bottom, long top) {
    return usage > bottom ? Math.min(usage, top) - bottom : 0;
  }
}
```
- 개인적으로 조건식 이해가 덜 됨
  - 조건식이다보니 middleBand를 복사해서 대체하고 하나씩 고친다는건데 .. 
  - 함수의 매개변수화라는게 동일한 함수에 매개변수 값을 달리넣어서 재활용하도록 바꾼다는 의미인듯

### 11.3 플래그 인수 제거하기
- 카탈로그: [Remove Flag Argument](https://refactoring.com/catalog/removeFlagArgument.html)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch11/ex3)
  - [테스트](../src/test/java/com/example/refactoring2/ch11/ex3)

<br/>

**배경**
- `플래그 인수(flag argument)`란 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위해 전달하는 인수다 
  - 🚫사용하지 말기
- 플래그 인수를 싫어하는 이유
  - 호출할 수 있는 함수들이 무엇이고 어떻게 호출해야 하는지를 이해하기가 어려워진다
- 플래그 인수를 제거하면 코드가 깔끔해짐은 물론 프로그래밍 도구에도 도움을 준다
- 플래그 인수가 둘 이상이면 함수 하나가 너무 많은 일을 처리하고 있다는 신호이기도 한다
- 그러니 같은 로직을 조합해내는 더 간단한 함수를 만들 방법을 고민해봐야 한다
<br/>

**절차**
- 매개변수로 주어질 수 있는 값 각각에 대응하는 명시적 함수들을 생성한다
  - 주가 되는 함수에 깔끔한 분배 조건문이 포함되어 있다면 조건문 분해하기로 명시적 함수들을 생성하자
  - 그렇지 래핑함수(wrapping function) 형태로 만든다
- 원래 함수를 호출하는 코드들을 모두 찾아서 각 리터럴 값에 대응되는 명시적 함수를 호출하도록 수정한다
<br/>

**💩before**
```java
public class Shipment {
  private LocalDate deliveryDate;

  public Shipment(LocalDate deliveryDate) {
    this.deliveryDate = deliveryDate;
  }

  public LocalDate deliveryDate(Order anOrder, boolean isRush) {
    if (isRush) {
      int deliveryTime;
      if (Set.of("MA", "CT").contains(anOrder.deliverySate())) {
        deliveryTime = 1;
      } else if (Set.of("NY", "NH").contains(anOrder.deliverySate())) {
        deliveryTime = 2;
      } else {
        deliveryTime = 3;
      }

      return anOrder.placedOn().plusDays(1 + deliveryTime);
    }

    int deliveryTime;
    if (Set.of("MA", "CT", "NY").contains(anOrder.deliverySate())) {
      deliveryTime = 2;
    } else if (Set.of("ME", "NH").contains(anOrder.deliverySate())) {
      deliveryTime = 3;
    } else {
      deliveryTime = 4;
    }

    return anOrder.placedOn().plusDays(2 + deliveryTime);
  }
}
```
<br/>

**✨after**
```java
public class Shipment {
  private LocalDate deliveryDate;

  public Shipment(LocalDate deliveryDate) {
    this.deliveryDate = deliveryDate;
  }

  private LocalDate regularDeliveryDate(Order anOrder) {
    int deliveryTime;
    if (Set.of("MA", "CT", "NY").contains(anOrder.deliverySate())) {
      deliveryTime = 2;
    } else if (Set.of("ME", "NH").contains(anOrder.deliverySate())) {
      deliveryTime = 3;
    } else {
      deliveryTime = 4;
    }

    return anOrder.placedOn().plusDays(2 + deliveryTime);
  }

  private LocalDate rushDeliveryDate(Order anOrder) {
    int deliveryTime;
    if (Set.of("MA", "CT").contains(anOrder.deliverySate())) {
      deliveryTime = 1;
    } else if (Set.of("NY", "NH").contains(anOrder.deliverySate())) {
      deliveryTime = 2;
    } else {
      deliveryTime = 3;
    }

    return anOrder.placedOn().plusDays(1 + deliveryTime);
  }

  public void setRushDeliveryDate(Order order) {
    this.deliveryDate = rushDeliveryDate(order);
  }

  public void setRegularDeliveryDate(Order order) {
    this.deliveryDate = regularDeliveryDate(order);
  }
  
  // equals, hashcode
}
```
- 이 함수가 어느 코드를 실행할지는 전적으로 호출자의 지시에 따른다
- 따라서 명시적인 함수를 사용해 호출자의 의도를 분명히 밝히는 편이 나을 것이다.
  - 플래그 인수를 사용하면 내부 구조를 알아야 되니, 명시적인 함수를 호출하도록 하는게 낫다는 의미인듯
  - 그래서 `setRushDeliveryDate(Order)`, `setRegularDeliveryDate(Order)`를 무엇을 사용할지는 호출자가 결정
<br/>

### 11.4 객체 통째로 넘기기
- 카탈로그: [Preserve Whole Object](https://refactoring.com/catalog/preserveWholeObject.html)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch11/ex4)
  - [테스트](../src/test/java/com/example/refactoring2/ch11/ex4)

<br/>

**배경**
- 하나의 레코드에서 값 두어 개를 가져와 인수로 넘기는 코드를 보면, **그 값들 대신 '최소한' 레코드를 통째로 넘기고 함수 본문에서 필요한 값들을 꺼내 쓰도록 수정하곤 한다**
- 레코드를 통째로 넘기면 변화에 대응하기 쉽다
- 함수가 레코드 자체에 의존하기를 원치 않을 때는 이 리팩터링을 수행하지 않는데, 레코드와 함수가 서로 다른 모듈에 속한 상황이면 특히 더 그렇다
- 어떤 객체로부터 값 몇 개를 얻을 후 그 값들만으로 무언가를 하는 로직이 있다면, 그 로직을 객체 안으로 집어넣어야 함을 알려주는 악취로 봐야 한다
  - 응집도 높이기 ! 

<br/>

**절차**
- 매개변수들을 원하는 형태로 받는 빈 함수를 만든다
  - 마지막 단계에서 이 함수의 이름을 변경해야 하니 검색하기 쉬운 이름으로 지어준다
- 새 함수의 본문에서는 원래 함수를 호출하도록 하며, 새 매개변수와 원래 함수의 매개변수를 매핑한다
- 정적 검사를 수행한다
- 모든 호출자가 새 함수를 사용하게 수정한다. 
  - 하나씩 수정하며 테스트하자
  - 수정 후에는 원래 매개변수를 만들어내는 코드 일부가 필요 없어질 수 있다
- 호출자를 모두 수정했다면 원래 `함수를 인라인`한다
- 새 함수의 이름을 적절히 수정하고 모든 호출자에 반영한다
<br/>

**💩before**
```java
public class HeatingPlan {
  private final TemperatureRange temperatureRange;

  public HeatingPlan(TemperatureRange temperatureRange) {
    this.temperatureRange = temperatureRange;
  }

  public boolean withinRange(int bottom, int top) {
    return (bottom >= this.temperatureRange.low()) && (top <= this.temperatureRange.high());
  }
}

public record Room(TemperatureRange daysTempRange) {}

public record TemperatureRange(int low, int high) {}

```
<br/>

**✨after**
```java
public class HeatingPlan {
  private final TemperatureRange temperatureRange;

  public HeatingPlan(TemperatureRange temperatureRange) {
    this.temperatureRange = temperatureRange;
  }

  public boolean withinRange(TemperatureRange aNumberRange) {
    return (aNumberRange.low() >= this.temperatureRange.low())
        && (aNumberRange.high() <= this.temperatureRange.high());
  }
}

```
- `xxNewWithinRange(TemperatureRange aNumberRange)`를 생성해서 기존 메서드 호출하도록 하는게 시작이구나
- 그리고 기존 `withinRange(int bottom, int top)`의 조건문을 인라인으로 옮겨서 대체하면 끝
<br/>

> **NOTE** "예시: 새 함수를 다른 방식으로 만들기"의 경우 우선 클라이언트 코드에서 함수 추출하기를 한 다음에 HeatingPlan 클래스 안으로 옮기는 거네 (이하 동일).
> 첫번째 설명은 애초에 HeatingPlan 안에 이름이 다른 메서드를 만들어서 호출 위임하는 거고.

### 11.5 매개변수를 질의 함수로 바꾸기
- 카탈로그: [Replace Parameter with Query](https://refactoring.com/catalog/replaceParameterWithQuery.html)
- 1판에서의 이름: 매개변수 세트를 메서드로 전환
- 반대 리팩터링: [질의 함수를 매개변수로 바꾸기](#116-질의-함수를-매개변수로-바꾸기)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch11/ex5)
  - [테스트](../src/test/java/com/example/refactoring2/ch11/ex5)

<br/>

**배경**
- 매개변수 목록은 함수의 변동 요인을 모아놓은 곳이다
- 즉, 함수의 동작에 변화를 줄 수 있는 일차적인 수단이다
  - 이 목록에서도 중복을 피하는게 좋으며 짧을수록 이해하기 쉽다
- 피호출 함수가 스스로 '쉽게' 결정할 수 있는 값을 매개변수로 건네는 것도 일종의 중복이다
- 이번 리팩터링의 한계는 '쉽게'라는 단어에 있다
  - 저자는 `습관적으로 호출하는 쪽을 간소하게 만든다`고 한다
  - 즉, 책임 소재를 피호출 함수로 옮긴다는 뜻인데, 물론 피호출 함수가 그 역할을 수행하기에 적합할 때만 그렇게 한다
- 매개변수를 질의 함수로 바꾸지 말아야 할 상황도 있다
  - 가장 흔한 예는 매개변수를 제거하면 피호출 함수에 원치 않는 의존성이 생길 때다
  - 즉, 해당 함수가 알지 못했으면 하는 프로그램 요소에 접근해야 하는 상황을 만들때다 (👨🏻‍💻결합도가 상승할 수 있겠구나)
- 그리고 주의사항이 하나 있다
  - 대상 함수(pure function)가 `참조 투명(referential transparency)` 해야 한다는 것이다
  - 참조 투명이란? `함수에 똑같은 값을 건네 호출하면 항상 똑같이 동작한다`는 뜻이다 (🤔멱등성일까?)
  - 이런 함수는 동작을 예측하고 테스트하기 훨씬 쉬우니 이 특성이 사라지지 않도록 주의하자
  - 따라서 매개변수를 없애는 대신 가변 전역 변수를 이용하는 일은 하면 안된다
<br/>

> 외부 의존성을 참조하고, 호출한 결과값을 사용하는 경우라면? 인터페이스 함수가 하나면 람다나 익명 함수 사용하거나 가짜 클래스를 만들어서 테스트 쉽게 할 수 있지 않을까?

**절차**
- 필요하다면 대상 매개변수의 값을 계산하는 코드를 별도 함수로 추출해놓는다 
- 함수 본문에서 대상 매개변수로의 참조를 모두 찾아서 그 매개변수의 값을 만들어주는 표현시을 참조하도록 바꾼다
  - 하나 수정할 때마다 테스트한다
- 함수 선언 바꾸기로 대상 매개변수를 없앤다
<br/>

**💩before**
```java
public class Order {
    private final int quantity;
    private final int itemPrice;

    public Order(int quantity, int itemPrice) {
        this.quantity = quantity;
        this.itemPrice = itemPrice;
    }

    public double finalPrice() {
        int basePrice = this.quantity * this.itemPrice;
        int discountLevel = this.quantity > 100 ? 2 : 1;
        return this.discountPrice(basePrice, discountLevel);
    }

    private double discountPrice(int basePrice, int discountLevel) {
        return switch (discountLevel) {
            case 1 -> basePrice * 0.95;
            case 2 -> basePrice * 0.9;
            default -> throw new IllegalStateException("Unexpected discountLevel: " + discountLevel);
        };
    }
}

```
<br/>

**✨after**
```java
public class Order {
    private final int quantity;
    private final int itemPrice;

    public Order(int quantity, int itemPrice) {
        this.quantity = quantity;
        this.itemPrice = itemPrice;
    }

    public double finalPrice() {
        int basePrice = this.quantity * this.itemPrice;
        return this.discountPrice(basePrice);
    }

    private int discountLevel() {
        return (this.quantity > 100) ? 2 : 1;
    }

    private double discountPrice(int basePrice) {
        return switch (this.discountLevel()) {
            case 1 -> basePrice * 0.95;
            case 2 -> basePrice * 0.9;
            default -> throw new IllegalStateException("Unexpected discountLevel: " + this.discountLevel());
        };
    }
}
```
<br/>

### 11.6 질의 함수를 매개변수로 바꾸기
- 카탈로그: [Replace Query with Parameter](https://refactoring.com/catalog/replaceQueryWithParameter.html)
- 반대 리팩터링: [매개변수를 질의 함수로 바꾸기](#115-매개변수를-질의-함수로-바꾸기)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch11/ex6)
  - [테스트](../src/test/java/com/example/refactoring2/ch11/ex6)

<br/>

**배경**
- 코드를 읽다보면 함수 안에 두기엔 거북한 참조를 발견할 때가 많다
- 전역 변수를 참조한다거나(같은 모듈 안에서라도) 제거하길 원하는 원소를 참조하는 경우가 여기 속한다
  - 이 문제는 해당 참조를 매개변수로 바꿔 해결할 수 있다
  - 참조를 풀어내는 책임을 호출자로 옮기는 것이다
- 이런 상황 대부분은 코드의 의존 관게를 바꾸려 할 때 벌어진다
- 예컨대 대상 함수가 더 이상 (매개변수화하려는) 특정 원소에 의존하길 원치 않을 때 일어난다
- 이때 **두 극단 사이에서 적절한 균형을 찾아야 한다**
- 프로그램을 더 잘 이해하게 됐을 때 더 나은 쪽으로 개선하기 쉽게 설계해두는게 중요하다
- 똑같은 값을 건네면 매번 똑같은 결과를 내는 함수는 다루기 쉽다
  - 이런 성질을 '참조 투명성'이라 한다
  - 참조 투명하지 않는 원소에 접근하는 모든 함수는 참조 투명성을 잃게 되는데, 이 문제는 해당 원소를 매개변수로 바꾸면 해결된다
- 모듈을 개발할 때 **순수 함수**들을 따로 구분하고, 프로그램의 입출력과 기타 가변 원소들을 다루는 로직으로 순수 함수들의 겉을 감싸는 패턴을 많이 활용한다

> 결국 책임 소재를 프로그램의 어디에 배정하냐의 문제로 귀결된다. 답을 찾기가 쉽지 않으며 항상 정답이 있는 것도 아니다.

<br/>

**절차**
- 변수 추출하기로 질의 코드를 함수 본문의 나머지 코드와 분리한다
- 함수 본문 중 해당 질의를 호출하지 않는 코드들을 별로 함수로 추출한다
  - 이 함수의 이름은 나중에 수정해야 하니 검색하기 쉬운 이름으로 짓는다
- 방금 만든 변수를 인라인하여 제거한다
- 원래 함수도 인라인한다
- 새 함수의 이름을 원래 함수의 이름으로 고쳐준다
<br/>

// 예시에서 Client와 HeatingPlan이 같은 온도 조절기(Thermostat)를 가지는게 맞는가 싶다

**💩before**
```java
public class Client {
  private final HeatingPlan thePlan;
  private final Thermostat thermostat; // 온도 조절기
  private AirConditionStatus status;

  public Client(HeatingPlan thePlan, Thermostat thermostat) {
    this.thePlan = thePlan;
    this.thermostat = thermostat;
    this.status = AirConditionStatus.DEFAULT;
  }

  public void controlTemperature() {
    if (thePlan.targetTemperature() > thermostat.currentTemperature()) {
      setToHeat();
    } else if (thePlan.targetTemperature() < thermostat.currentTemperature()) {
      setToCool();
    } else {
      setOff();
    }
  }

  public AirConditionStatus getStatus() {
    return status;
  }

  public enum AirConditionStatus {
    HEAT,
    COOL,
    OFF,
    DEFAULT;
  }

  private void setToCool() {
    this.status = AirConditionStatus.COOL;
  }

  private void setToHeat() {
    this.status = AirConditionStatus.HEAT;
  }

  private void setOff() {
    this.status = AirConditionStatus.OFF;
  }
}

public class HeatingPlan {
    private final int max;
    private final int min;
    private final Thermostat thermostat; // 온도 조절기

    public HeatingPlan(int max, int min, Thermostat thermostat) {
        this.max = max;
        this.min = min;
        this.thermostat = thermostat;
    }

    public int targetTemperature() {
        if (thermostat.selectedTemperature() > this.max) {
            return this.max;
        } else if (thermostat.selectedTemperature() < this.min) {
            return this.min;
        }

        return thermostat.selectedTemperature();
    }

}
```
<br/>

**✨after**
```java
public class Client {
  private final HeatingPlan thePlan;
  private final Thermostat thermostat; // 온도 조절기
  private AirConditionStatus status;

  public Client(HeatingPlan thePlan, Thermostat thermostat) {
    this.thePlan = thePlan;
    this.thermostat = thermostat;
    this.status = AirConditionStatus.DEFAULT;
  }

  public void controlTemperature() {
    if (thePlan.targetTemperature(thermostat.selectedTemperature()) > thermostat.currentTemperature()) {
      setToHeat();
    } else if (thePlan.targetTemperature(thermostat.selectedTemperature()) < thermostat.currentTemperature()) {
      setToCool();
    } else {
      setOff();
    }
  }

  public AirConditionStatus getStatus() {
    return status;
  }

  public enum AirConditionStatus {
    HEAT,
    COOL,
    OFF,
    DEFAULT;
  }

  private void setToCool() {
    this.status = AirConditionStatus.COOL;
  }

  private void setToHeat() {
    this.status = AirConditionStatus.HEAT;
  }

  private void setOff() {
    this.status = AirConditionStatus.OFF;
  }
}


public class HeatingPlan {
    private final int max;
    private final int min;
    private final Thermostat thermostat; // 온도 조절기

    public HeatingPlan(int max, int min, Thermostat thermostat) {
        this.max = max;
        this.min = min;
        this.thermostat = thermostat;
    }

    public int targetTemperature(int selectedTemperature) {
        if (selectedTemperature > this.max) {
            return this.max;
        } else if (selectedTemperature < this.min) {
            return this.min;
        }

        return selectedTemperature;
    }

}
```

> **INFO** 이 리팩터링을 수행하면 호출하는 쪽 코드는 전보다 다루기 어려워지는게 보통이다. '의존성을 모듈 바깥으로 밀어낸다'함은 그 의존성을 처리하는 책임을 호출자에게 지운다는 뜻이기 때문이다.

<br/>

- 추가로 이 리팩터링으로 얻은 것이 온도 조절기 객체와의 결합을 제거한 것만은 아니다. HeatingPlan이 불변 클래스가 되었고, 테스트하기 쉬워졌다
- 따라서 `targetTemperature()`에 같은 인수를 넘겨 호출하면 언제나 똑같은 결과를 돌려줄 것이다
- 난방 계획의 메서드도 모두 참조 투명하다면, 이 클래스도 테스트하고 다루기가 쉬워졌을 것이다

<br/>

> 📖읽어보기. p441 자바스크립트와 불변 클래스


<br/>


### 11.7 세터 제거하기
- 카탈로그: [Remove Setting Method](https://refactoring.com/catalog/removeSettingMethod.html)
- 예시 ❎

<br/>

**배경**
- 세터 메서드가 있다고 함은 필드가 수정될 수 있다는 뜻이다
- 객체 생성 후에는 수정되지 않길 원하는 필드라면 세터를 제공하지 않았을 것이다
- 이 리팩터링이 필요한 상황은 주로 두 가지이다
  - 1. 사람들이 무조건 접근자 메서드를 통해서만 필드를 다루려 할 때다
    - 심지어 생성자 안에서만 세터를 호출하기도 하는데, **세터를 제거해서 객체가 생성된 후에는 값이 바뀌면 안 된다는 뜻을 분명히 할 것이다**
  - 2. 클라이언트에서 **생성 스크립트**를 사용해 객체를 생성할 때다
    - 생성 스크립트란 생성자를 호출한 후 일련의 세터를 호출하여 객체를 완성하는 형태의 코드를 말한다
    - 그러면서 설계자는 스크립트가 완료된 뒤로는 그 객체의 필드 일부(혹은 전체)가 변경되지 않으리라 기대한다
    - **이런 경우에도 세터들을 제거하여 의도를 더 정확하게 전달하는게 좋다**
<br/>

**절차**
- 설정해야 할 값을 생성자에서 받지 않는다면 그 값을 받을 매개변수를 생성자에 추가한다
  - 그런 다음 생성자 안에서 적절한 세터를 호출한다
- 생성자 밖에서 세터를 호출하는 곳을 찾아 제거하고 대신 새로운 생성자를 사용하도록 한다.
  - 하나 수정할 때마다 테스트한다
- 세터 메서드를 인라인한다. 가능하다면 해당 필드를 불변으로 만든다
- 테스트한다
<br/>


### 11.8 생성자를 팩터리 함수로 바꾸기
- 카탈로그: [Replace Constructor with Factory Function](https://refactoring.com/catalog/replaceConstructorWithFactoryFunction.html)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch11/ex8)
  - [테스트](../src/test/java/com/example/refactoring2/ch11/ex8)

<br/>

> 캡슐화 ➡️ 팩토리 사용

**배경**
- 생성자는 객체를 초기화하는 특별한 용도의 함수다
<br/>

**절차**
- 팩터리 함수를 만든다. 팩터리 함수의 본문에서는 원래의 생성자를 호출한다
- 생성자를 호출하던 코드를 팩터리 함수 호출로 바꾼다
- 하나씩 수정할 때마다 테스트한다
- 생성자의 가시범위가 최소가 되도록 제한다
<br/>

**💩before**
```java
public record Employee(String name, String typeCode) {

  public LegalTypeCode type() {
    return LegalTypeCode.from(typeCode);
  }

  enum LegalTypeCode {
    ENGINEER("E"),
    MANAGER("M"),
    SALESPERSON("S");

    private final String typeCode;

    LegalTypeCode(String typeCode) {
      this.typeCode = typeCode;
    }

    public static LegalTypeCode from(String typeCode) {
      return Arrays.stream(values())
          .filter(c -> c.typeCode.equals(typeCode))
          .findFirst()
          .orElseThrow(IllegalArgumentException::new);
    }
  }
}
```
<br/>

**✨after**
```java
public record Employee(String name, String typeCode) {

  public static Employee createEngineer(String name) { 
    return new Employee(name, "E"); // ✨
  }

  public LegalTypeCode type() {
    return LegalTypeCode.from(typeCode);
  }

  enum LegalTypeCode {
    ENGINEER("E"),
    MANAGER("M"),
    SALESPERSON("S");

    private final String typeCode;

    LegalTypeCode(String typeCode) {
      this.typeCode = typeCode;
    }

    public static LegalTypeCode from(String typeCode) {
      return Arrays.stream(values())
          .filter(c -> c.typeCode.equals(typeCode))
          .findFirst()
          .orElseThrow(IllegalArgumentException::new);
    }
  }
}
```
<br/>


### 11.9 함수를 명령으로 바꾸기
- 카탈로그: [Replace Function with Command](https://refactoring.com/catalog/replaceFunctionWithCommand.html)
- 1판에서의 이름: 메서드를 메서드 객체로 전환
- 반대 리팩터링: [명령을 함수로 바꾸기](#1110-명령을-함수로-바꾸기-)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch11/ex9)
  - [테스트](../src/test/java/com/example/refactoring2/ch11/ex9)

<br/>

**배경**
- 함수(독립된 함수나 객체 소속된 메서드)는 프로그래밍의 기본 빌딩 블록 중 하나다
- 그런데 함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있다
- 이런 객체를 가리켜 **'명령 객체'** 혹은 단순히 **'명령(command)'** 라 한다
  - 메서드를 요청해 실행하는 것이 이 명령 객체의 목적이다
- 명령을 이용해 **일급 함수**의 기능 대부분을 흉내낼 수 있다
- 이처럼 명령을 사용해 얻는 이점이 많으므로 함수를 명령으로 리팩터링할 채비를 갖춰야 할 것이다
  - 하지만 유연성은 (언제나 그렇듯) 복잡성을 키우고 얻는 대가임을 잊지 말아야 한다
- 저자는 말한다
  - **일급 함수와 명령 중 선택해야 한다면, 저자라면 95%는 일급 함수의 손을 들어준다**고 말한다
  - 그리고 명령을 선택할 때는 명령보다 더 간단한 방식으로는 얻을 수 없는 기능이 필요할 때뿐이다
<br/>

**절차**
- 대상 함수의 기능을 옮길 빈 클래스를 만든다. 클래스 이름은 함수 이름에 기초해 짓는다
- 방금 생성한 빈 클래스로 함수를 옮긴다
  - 리팩터링이 끝날 때까지는 원래 함수를 전달 함수 역할로 남겨두자
  - 명령 관련 이름은 사용하는 프로그래밍 언어의 명명 규칙을 따른다
  - 규칙이 딱히 없다면 `execute`나 `call`과 같은 흔한 실행 함수명을 택하자
- 함수의 인수들 각각의 명령의 필드로 만들어 생성자를 통해 설정할지 고민해본다
<br/>


📚**명령**
- 소프트웨어 개발에 여러 가지 의미로 사용
- 지금 맥락에서 명령은 요청을 캡슐화한 객체로, 디자인 패턴 중 `명령 패턴(COMMAND PATTERN)`에서 말하는 명령과 같다
- 한편 명령-질의 분리 원칙에서도 명령이 등장하는데, 이때 명령은 객체의 겉보기 상태를 변경하는 메서드를 가르킨다
  - 이 책에서는 이 의미의 명령을 이야기할 때는 명령이란 단어를 쓰지 않고, `변경 함수(modifier or mutator)`라 하겠다

<br/>

**💩before** <br/>
복잡한 함수를 잘게 쪼개서 이해하거나 수정하기 쉽게 만들고자 할 때에 대한 예시이다
```java
public class Insurance {

  public int score(Candidate candidate, MedicalExam medicalExam, ScoringGuide scoringGuide) {
    int result = 0;
    int healthLevel = 0;
    boolean highMedicalRiskFlag = false;

    if (medicalExam.isSmoker()) {
      healthLevel += 10;
      highMedicalRiskFlag = true;
    }

    String certificationGrade = "regular";
    if (scoringGuide.startWithLowCertification(candidate.originState())) {
      certificationGrade = "low";
      result -= 5;
    }

    // do something ..

    result -= Math.max(healthLevel - 5, 0);
    return result;
  }
}


public record ScoringGuide() {
  public boolean startWithLowCertification(String state) {
    return state.startsWith("low");
  }
}

public record MedicalExam(boolean isSmoker) {}

public record Candidate(String originState) {}
```
<br/>

**✨after**
```java
public class Insurance {

  public int score(Candidate candidate, MedicalExam medicalExam, ScoringGuide scoringGuide) {
    return new Score(candidate, medicalExam, scoringGuide).execute();
  }
}


public class Score { // 명령 객체
  private final Candidate candidate;
  private final MedicalExam medicalExam;
  private final ScoringGuide scoringGuide;

  public Score(Candidate candidate, MedicalExam medicalExam, ScoringGuide scoringGuide) {
    this.candidate = candidate;
    this.medicalExam = medicalExam;
    this.scoringGuide = scoringGuide;
  }

  public int execute() {
    {
      int result = 0;
      int healthLevel = 0;
      boolean highMedicalRiskFlag = false;

      if (this.medicalExam.isSmoker()) {
        healthLevel += 10;
        highMedicalRiskFlag = true;
      }

      String certificationGrade = "regular";
      if (this.scoringGuide.startWithLowCertification(this.candidate.originState())) {
        certificationGrade = "low";
        result -= 5;
      }

      // do something ..

      result -= Math.max(healthLevel - 5, 0);
      return result;
    }
  }
}
```

🧹**더 가다듬기**. 모든 지역 변수를 필드로 바꾸며 메서드 추출할 수 있다
```java
public class Score { 
  private final Candidate candidate;
  private final MedicalExam medicalExam;
  private final ScoringGuide scoringGuide;
  private int result;
  private int healthLevel;
  private boolean highMedicalRiskFlag;
  private String certificationGrade;

  public Score(Candidate candidate, MedicalExam medicalExam, ScoringGuide scoringGuide) {
    this.candidate = candidate;
    this.medicalExam = medicalExam;
    this.scoringGuide = scoringGuide;
  }

  public int execute() {
    {
      this.result = 0;
      this.healthLevel = 0;
      this.highMedicalRiskFlag = false;

      this.scoreSmoking();
      this.scoreLowCertification();

      // do something ..
      this.result -= Math.max(this.healthLevel - 5, 0);
      return this.result;
    }
  }

  private void scoreSmoking() {
    if (this.medicalExam.isSmoker()) {
      this.healthLevel += 10;
      this.highMedicalRiskFlag = true;
    }
  }

  private void scoreLowCertification() {
    this.certificationGrade = "regular";
    if (this.scoringGuide.startWithLowCertification(this.candidate.originState())) {
      this.certificationGrade = "low";
      this.result -= 5;
    }
  }
}
```

> **INFO** 명령을 사용하면 서브 함수들을 테스트와 디버깅에 활용할 수 있기 때문에 유용하다 (p455)

<br/>

### 11.10 명령을 함수로 바꾸기 
- 카탈로그: [Replace Command with Function](https://refactoring.com/catalog/replaceCommandWithFunction.html)
- 반대 리팩터링: [함수를 명령으로 바꾸기](#119-함수를-명령으로-바꾸기)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch11/ex10)
  - [테스트](../src/test/java/com/example/refactoring2/ch11/ex10)

<br/>

**배경**
- 명령 객체는 복잡한 연산을 다룰 수 있는 강력한 메커니즘을 제공한다
- 명령의 이런 능력은 공짜가 아니다. 명령은 그저 함수를 하나 호출해 정해진 일을 수행하는 용도로 주로 쓰인다
- 이런 상황이고 로직이 크게 복잡하지 않다면 명령 객체는 장점보다 단점이 크니 펴엄한 함수로 바꿔주는게 낫다
<br/>

**절차**
- 명령을 생성하는 코드와 명령의 실행 메서드를 호출하는 코드를 함께 함수로 추출한다
  - 이 함수가 바로 명령을 대체할 함수다
- 명령의 실행 함수가 호출하는 보조 메서드를 각각을 인라인한다
  - 보조 메서드가 값을 반환한다면 함수 인라인에 앞서 변수 추출하기를 적용한다
- 함수 선언 바꾸기를 적용하여 생성자의 매개변수 모두를 명령의 실행 메서드로 옮긴다
- 명령의 실행 메서드에서 참조하는 필드를 대신 대응하는 매개변수를 사용하게끔 바꾼다
  - 하나씩 수정할 때마다 테스트한다
- 생성자 호출과 명령의 실행 메서드 호출을 호출자(대체 함수) 안으로 인라인한다
- 테스트한다
- 죽은 코드 제거하기로 명령 클래스를 없앤다
<br/>

**💩before**
```java
public class ChargeCalculator { // 명령 객체

  private final Customer customer;
  private final int usage;
  private final Provider provider;

  public ChargeCalculator(Customer customer, int usage, Provider provider) {
    this.customer = customer;
    this.usage = usage;
    this.provider = provider;
  }

  public double charge() {
    return this.baseCharge() + this.provider.connectionCharge();
  }

  private double baseCharge() {
    return this.customer.baseRate() * this.usage;
  }
}


class ChargeCalculatorTest {

  @Test
  void chargeTest() {
    Customer customer = new Customer(0.1);
    int usage = 1000;
    Provider provider = new Provider(100);
    
    // 호출자
    ChargeCalculator chargeCalculator = new ChargeCalculator(customer, usage, provider);
    double actual = chargeCalculator.charge();

    assertThat(actual).isEqualTo(200.0);
  }
}

```
<br/>

**✨after**
```java
public class ChargeCalculator { 

  public ChargeCalculator() {}

  public double charge(Customer customer, int usage, Provider provider) { // 함수 
    double baseCharge = customer.baseRate() * usage;
    return baseCharge + provider.connectionCharge();
  }
}


class ChargeCalculatorTest {

  @Test
  void chargeTest() {
    Customer customer = new Customer(0.1);
    int usage = 1000;
    Provider provider = new Provider(100);

    double actual = charge(customer, usage, provider);

    assertThat(actual).isEqualTo(200.0);
  }

  private double charge(Customer customer, int usage, Provider provider) {
    return new ChargeCalculator().charge(customer, usage, provider);
  }
}
```
<br/>

### 11.11 수정된 값 변환하기
- 카탈로그: [Return Modified Value](https://refactoring.com/catalog/returnModifiedValue.html)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch11/ex11)
  - [테스트](../src/test/java/com/example/refactoring2/ch11/ex11)

<br/>

**배경**
- 데이터가 어떻게 수정되는지를 추적하는 일은 코드에서 이해하기 가장 어려운 부분 중 하나다
- 특히 같은 데이터 블록을 읽고 수정하는 코드가 여러 곳이라면 데이터가 수정되는 흐름과 코드의 흐름을 일치시키기가 상당히 어렵다
- 그래서 데이터가 수정된다면 그 사실을 명확히 알려주어서, 어느 함수가 무슨 일을 하는지 쉽게 알 수 있게 하는 일이 대단히 중요하다
- 이 리팩터링은 값 하나를 계산한다는 분명한 목적이 있는 함수들에 가장 효과적이고, 반대로 값 여러 개를 갱신하는 함수에는 효과적이지 않다
<br/>

**절차**
- 함수가 수정된 값을 반환하게 하여 호출자가 그 값을 자신의 변수에 저장하게 한다
- 테스트한다
- 피호출 함수 안에 반환할 값을 가리키는 새로운 변수를 선언한다
  - 이 작업이 의도대로 이뤄졌는지 검사하고 싶다면 호출자에서 초깃값을 수정해보자 
  - 제대로 처리했다면 수정된 값이 무시된다
- 테스트한다
- 계산이 선언과 동시에 이뤄지도록 통합한다 (즉, 선언 시점에서 계산 로직을 바로 실행해 대입한다)
- 테스트한다
- 피호출 함수의 변수 이름을 새 역할에 어울리도록 바꿔준다
- 테스트한다
<br/>

**💩before**
```java
public class GpsCalculator {
  private int totalAscent = 0;
  private int totalTime = 0;
  private int totalDistance = 1; // / by zero 오류 때문에 1로 초기화
  private final Point[] points;

  public GpsCalculator(Point[] points) {
    this.points = points;
  }

  public double calculate() {
    calculateAscent();
    calculateTime();
    calculateDistance();
    return (double) totalTime / 60 / totalDistance;
  }

  public void calculateAscent() {
    for (int i = 1; i < points.length; i++) {
      int verticalChange = points[i].elevation() - points[i - 1].elevation();
      totalAscent += Math.max(verticalChange, 0);
    }
  }

  public void calculateTime() {
    // ignore: do something
  }

  public void calculateDistance() {
    // ignore: do something
  }
}
```
<br/>

**✨after**
생략된게 많아서 그렇지 전역 필드로 관리하기 보다는 함수 scope 안에 지역 변수를 사용하라는 내용인듯하다
```java
public class GpsCalculator {
  private final Point[] points;

  public GpsCalculator(Point[] points) {
    this.points = points;
  }

  public double calculate() {
    int totalAscent = calculateAscent();
    int totalTime = calculateTime();
    int totalDistance = calculateDistance();
    return (double) totalTime / 60 / totalDistance;
  }

  public int calculateAscent() {
    int result = 0;
    for (int i = 1; i < points.length; i++) {
      int verticalChange = points[i].elevation() - points[i - 1].elevation();
      result += Math.max(verticalChange, 0);
    }

    return result;
  }

  public int calculateTime() {
    // ignore: do something
    return 0;
  }

  public int calculateDistance() {
    // ignore: do something
    // / by zero 때문에 1로 초기화
    return 1;
  }
}
```
- 멤버 필드로 관리 (갱신)하는 것보다 메서드별 결과값을 반환하여 사용하는 형태가 안전한 듯
<br/>

### 11.12 오류 코드를 예외로 바꾸기
- 카탈로그: [Replace Error Code with Exception](https://refactoring.com/catalog/replaceErrorCodeWithException.html)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch11/ex12)

<br/>

**배경**
- 과거에는 오류 코드(error code)를 사용하는 게 보편적이었다
  - 임의 숫자 (`-1, -2`)
- 예외는 정교한 매커니즘이지만 대다수의 다른 정교한 매커니즘과 같이 정확하게 사용할 때만 최고의 효과를 낸다
- 예외는 정확히 예상 밖의 동작일 때만 쓰여야 한다
<br/>

**절차**
- 콜스택 상위에 해당 예외를 처리할 예외 핸들러를 작성한다
- 테스트한다
- 해당 오류 코드를 대체할 예외와 그 밖의 예외를 구분할 식별 방법을 찾는다
- 정적 검사를 수행한다 
- catch절을 수정하여 직접 처리할 수 있는 예외는 적절히 대처하고 그렇지 않은 예외는 다시 던진다
- 테스트한다
- 오류 코드를 반환하는 곳 모두에서 예외를 던지도록 수정한다. 하나씩 수정할 때마다 테스트한다
- 모두 수정했다면 그 오류 코드를 콜스택 위로 전달하는 코드를 모두 제거한다. 하나씩 수정할 때마다 테스트한다
<br/>

**💩before**
```java
public class CountryRule {
  private final CountryData countryData;

  public CountryRule(CountryData countryData) {
    this.countryData = countryData;
  }

  public void topMethod(Order orderData) {
    Object status = calculateShippingCosts(orderData);
    List<ErrorInfo> errorList = new ArrayList<>();
    if (!(status instanceof ShippingRules) && (int) status < 0) {
      errorList.add(new ErrorInfo(orderData, (int) status));
    }
  }

  public Object calculateShippingCosts(Order anOrder) {
    // 관련 없는 코드

    Object shippingRules = localShippingRules(anOrder.country());
    if (!(shippingRules instanceof ShippingRules)) {
      return shippingRules; // 오류 전파
    }

    // 더 관련 없는 코드
    return BigDecimal.valueOf(0);
  }

  public Object localShippingRules(String country) {
    String data = countryData.shippingRules(country);

    if (data == null) return -23;

    return new ShippingRules(data);
  }
}
```
- `localShippingRules`에서 국가정보(`country`)가 유효한지 이 함수 호출 전에 다 검증했다고 가정한다
  - 따라서 이 함수에서 오류가 난다면 무언가 잘못됐음을 뜻한다 (?)  
  - 그래서 호출한 곳(`calculateShippingCosts`)에서 반환된 오류 코드를 검사하여 오류가 발견되면 위로 전파한다
- 더 윗단 함수(`topMethod`)는 오류를 낸 주문을 오류 목록(`errorList`)에 넣는다
- 여기서 가장 먼저 고려할 것은 이 오류가 '예상된 것이냐'다.
<br/>

**✨after**
```java
public class CountryRule {
  private final CountryData countryData;

  public CountryRule(CountryData countryData) {
    this.countryData = countryData;
  }

  public void topMethod(Order orderData) {
    List<ErrorInfo> errorList = new ArrayList<>();
    try {
      calculateShippingCosts(orderData);
    } catch (OrderProcessingException e) {
      errorList.add(new ErrorInfo(orderData, e.code()));
    } catch (Exception e) {
      throw new IllegalStateException(e);
    }
  }

  public void calculateShippingCosts(Order anOrder) {
    // 관련 없는 코드
    ShippingRules shippingRules = localShippingRules(anOrder.country());
    // 더 관련 없는 코드
  }

  public ShippingRules localShippingRules(String country) {
    String data = countryData.shippingRules(country);

    if (data == null) throw new OrderProcessingException(-23);

    return new ShippingRules(data);
  }
}
```

<br/>

**참고. 🤖Chat-GPT 답변** 
- 💩기존 코드의 문제점
  - `-23` 같은 숫자로 오류를 나타내면 의미를 알기 어려움
  - 그리고 호출한 쪽에서 이 오류를 항상 검사해야 함
  - 이때 실수로 검사하지 않으면 이상한 값이 프로그램 흐름을 깨뜨릴 가능성이 있다
- ✨리팩터링 후 개선된 점
  - 예외 발생시 즉시 코드 실행 중단
  - 예외 메시지를 포함하면 더 직관적인 오류 확인 가능
  - 호출한 쪽에서 try-catch로 한 번만 예외를 잡으면 됨(여러 메서드에서 검사할 필요 없음)

### 11.13 예외를 사전확인으로 바꾸기
- 카탈로그: [Replace Exception with Precheck](https://refactoring.com/catalog/replaceExceptionWithPrecheck.html)
- 1판에서의 이름: 예외 처리를 테스트로 교체
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch11/ex13)
  - [테스트](../src/test/java/com/example/refactoring2/ch11/ex13)

<br/>

**배경**
- 예외는 **뜻밖의 오류**라는, 말 그대로 예외적으로 동작할 때만 쓰여야 한다
- 함수 수행 시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있다면, 예외를 던지는 대신 호출하는 곳에서 조건을 검사하도록 해야 한다
<br/>

**절차**
- 예외를 유발하는 상황을 검사할 수 잇는 조건문을 추가한다
  - catch 블록의 코드를 조건문의 조건절 중 하나로 옮기고, 남은 try 블록의 코드를 다른 조건절로 옮긴다
- catch 블록에 어서션을 추가하고 테스트한다
- try문과 catch 블록을 제거한다 
- 테스트한다
<br/>

**💩before**
```java
public class ResourcePool {
  private Deque<Resource> available;
  private List<Resource> allocated;

  public ResourcePool() {
    this(new ArrayDeque<>(), new ArrayList<>());
  }

  public ResourcePool(Deque<Resource> available, List<Resource> allocated) {
    this.available = available;
    this.allocated = allocated;
  }

  public Resource get() {
    Resource result;

    try {
      result = available.pop();
      allocated.add(result);
    } catch (NoSuchElementException e) {
      result = Resource.create();
      allocated.add(result);
    }

    return result;
  }
}


public record Resource(String name) {
  public static Resource create() {
    return new Resource("dummy");
  }
}
```
<br/>

> **NOTE** AssertionError를 catch문에서 던지기보다 assert 키워드를 사용할 때가 많지만, 그러면 result가 초기화 되지 않을 수 있다며 컴파일러가 불평할 것이다 

**✨after**
```java
public class ResourcePool {
  private Deque<Resource> available;
  private List<Resource> allocated;

  public ResourcePool() {
    this(new ArrayDeque<>(), new ArrayList<>());
  }

  public ResourcePool(Deque<Resource> available, List<Resource> allocated) {
    this.available = available;
    this.allocated = allocated;
  }

  public Resource get() {
    Resource result = available.isEmpty() ? Resource.create() : available.pop();
    allocated.add(result);
    return result;
  }
}
```
- Deque가 isEmpty() 인지 확인하는 조건문을 시작으로 리팩터링을 수행
- try catch가 제거되고, 조건문 또한 단순하기 때문에 3항 연산자로 변경
<br/>

---
### Reference.
- [Command Query Separation](https://martinfowler.com/bliki/CommandQuerySeparation.html)
