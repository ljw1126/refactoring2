# Chapter12. 상속 다루기
## 후기

이번 챕터 학습을 통해 상속을 리팩터링 하는 과정에 익숙해질 수 있어서 좋았다. 
상속을 이론으로 배운 이후로는 실무에서 직접 구현해 본 적이 거의 없었다.
그러다 보니 `탬플릿 메서드 패턴이 상속의 이상적인 형태`라거나 `상속보다는 위임(Composition)을 사용해라` 등의 언급을 여러 번 접했지만 와닿지 않아 상속을 멀리했었다.
하지만 마지막 예시에서 슈퍼 클래스나 서브 클래스를 위임으로 리팩터링 하는 과정을 통해 `상속보다는 위임(Composition)을 사용해라`는 말이 무엇인지 이제서야 이해할 수 있었다.
그리고 위임 객체의 타입을 인터페이스뿐만 아니라 상속으로 표현할 수 있다는 걸 처음 알게 되어 인상적이었다.

<br/>

상속을 위임으로 리팩터링하면서 순환 참조 이슈가 많이 발생했다. 
그 중 기억남는 것은 12.10 두번째 예시였다.

<br/>

**💩before** <br/>
`Bird` ➡️ `SpeciesDelegate` ➡️ `Bird` 순환참조 발생
```java
public class Bird {
    private final String name;
    private final String plumage;
    private final SpeciesDelegate speciesDelegate; 

    private Bird(BirdDto birdDto) {
        this.name = birdDto.name();
        this.plumage = birdDto.plumage();
        this.speciesDelegate = selectSpeciesDelegate(birdDto);
    }

    private SpeciesDelegate selectSpeciesDelegate(BirdDto birdDto) {
        return switch (birdDto.type()) {
            case "유럽 제비" -> new EuropeanSwallowDelegate(this);
            case "아프리카 제비" -> new AfricanSwallowDelegate(birdDto, this);
            case "노르웨이 파랑 앵무" -> new NorwegianBlueParrotDelegate(birdDto, this);
            default -> new SpeciesDelegate(this);
        };
    }

    public static Bird from(BirdDto data) {
        return new Bird(data);
    }

    public String name() {
        return name;
    }

    public String plumage() {
        return this.speciesDelegate.plumage();
    }

    public Integer airSpeedVelocity() {
        return this.speciesDelegate.airSpeedVelocity();
    }

}


public class SpeciesDelegate {
  protected final Bird bird; // 💩

  protected SpeciesDelegate(Bird bird) {
    this.bird = bird;
  }

  public String plumage() {
    String plumage = this.bird.plumage();
    return plumage.isBlank() ? "보통이다" : plumage;
  }

  public Integer airSpeedVelocity() {
    return null;
  }
}

public class NorwegianBlueParrotDelegate extends SpeciesDelegate { // 노르웨이 파랑 앵무
  private final int voltage;
  private final boolean isNailed;

  public NorwegianBlueParrotDelegate(BirdDto data, Bird bird) {
    super(bird);
    this.voltage = data.voltage();
    this.isNailed = data.isNailed();
  }

  @Override
  public String plumage() {
    if (voltage > 100) return "그을렸다";

    return this.bird.plumage().isBlank() ? "예쁘다" : this.bird.plumage(); // 💩
  }

  @Override
  public Integer airSpeedVelocity() {
    return isNailed ? 0 : 10 + voltage / 10;
  }
}
```

**참고.**
<img src="https://github.com/ljw1126/user-content/blob/master/refactoring2/ch12/12.10-1.png?raw=true"/>

<br/>

**✨after**
```java
public class Bird {
  private final String name;
  private final String plumage;
  private final SpeciesDelegate speciesDelegate;

  private Bird(BirdDto birdDto) {
    this.name = birdDto.name();
    this.plumage = birdDto.plumage();
    this.speciesDelegate = selectSpeciesDelegate(birdDto);
  }

  private SpeciesDelegate selectSpeciesDelegate(BirdDto birdDto) {
    return switch (birdDto.type()) {
      case "유럽 제비" -> new EuropeanSwallowDelegate();
      case "아프리카 제비" -> new AfricanSwallowDelegate(birdDto);
      case "노르웨이 파랑 앵무" -> new NorwegianBlueParrotDelegate(birdDto);
      default -> new SpeciesDelegate();
    };
  }

  public static Bird from(BirdDto data) {
    return new Bird(data);
  }

  public String name() {
    return name;
  }

  public String plumage() {
    return this.speciesDelegate.plumage(this.plumage); // ✨
  }

  public Integer airSpeedVelocity() {
    return this.speciesDelegate.airSpeedVelocity();
  }
}
```
<img src="https://github.com/ljw1126/user-content/blob/master/refactoring2/ch12/12.10-3.png?raw=true"/>

- Bird에서 `plumage()` 호출시 파라미터 주입을 하는 형태로 하여 순환참조 이슈를 해결했다.
- 이외에도 필요한 필드만 생성자 초기화시 넘기거나, 필요한 기능을 따라 뽑아 인터페이스로 추상화하여 주입 받는 방법도 고려할 수 있다.
- 자식이 부모 참조하여 편한 것도 있었는데, 개인적으로 지금과 같은 안전한 상황에서는 허용해도 괜찮지 않았을까 라는 생각도 들었다. (🤔)

<br/>


**참고.** [인프런 - 상태패턴의 순환참조는 사용해도 좋은 것인가요?](https://www.inflearn.com/community/questions/391143?focusComment=158969)
> 순환 참조는 가급적이면 피하는게 좋은데요 (..)
> State 쪽에서 Context를 필드로 가져도 되지만 State에 있는 메소드를 호출할 때 Context를 매개변수로 넘겨줄수도 있습니다. 
> 매개변수로 넘기더라도 State와 Context는 상호간에 참조를 하긴하지만 필드를 가지고 생성자로 넘겨줘야 할 때 보다는 객체 생성이나 순환 참조로 인한 이슈가 줄어들긴 할 겁니다. (..)

<br/>

**🤖Chat-GPT**
- ✅ 왜 순환 참조를 피하려고 할까?
  - 테스트 어려움: Delegate를 테스트하려면 Bird를 먼저 만들어야 하고 → 복잡함.
  - 결합도 증가: Delegate가 Bird 내부 구조에 의존 → Bird 바뀌면 Delegate 깨질 수 있음.
  - 순환 의존에 따른 코드 냄새: 디버깅 어려워지고, 설계가 꼬이기 쉬움.
  - 객체 수명 관리 복잡: this를 생성자에 넘기는 순간 "아직 초기화 중인 객체"를 넘기는 것이므로, NullPointerException 위험도.
- ☝️실무 팁
  - 상속은 리팩터링 후반에 고려, 초반에는 인터페이스로 유연하게 시작
  - "이게 상속(`is-a`)이야? 아니면 단순 위임(`has-a`)이면 되나?" 스스로 질문해보기
  - 가능하면 상속보다 구성(composition) → `has-a` 관계 권장

**💡프로그래밍에서 Context 의미**
- 특정 작업이나 상태, 환경에 대한 정보를 캡슐화하는 것을 의미 
  - 1. 상태 및 환경 정보 캡슐화: 특정 작업이나 알고리즘을 수행하는데 필요한 상태나 환경 정보를 캡슐화하여 전달하거나 관리함
  - 2. 작업 전환 관리: 작업이 중단되거나 나중에 같은 지점에서 계속될 수 있도록 상태를 저장하고 복구함
- 예시.
  - **데이터베이스 컨텍스트** : DB 연결 및 트랜잭션 상태를 관리
  - **웹 애플리케이션 컨텍스트** : 웹 애플리케이션의 구성 및 상태 정보를 관리 (또는 서블릿 컨텍스트)
  - **멀티스레딩과 프로세스 컨텍스트** : 현재 실행 중인 스레드 또는 프로세스의 상태를 저장하고 복구하는 역할 


```text
12.10 배경 中
- 유명한 원칙 중 하나가 있다
  - '(클래스) 상속 보다는 (객체) 컴포지션을 사용하라'
  - 여기서 컴포지션(composition)은 사실상 위임과 같은 말이다
  - 위임을 알고 있다면 처음에 상속으로 접근한 다음, 문제가 생기면 위임으로 갈아탄다
- 디자인패턴 책은 상속과 컴포지션을 함께 사용하는 방법을 설명해준다
  - 이 원칙은 상속을 쓰지 말라는 게 아니라, 과용하는 데 따른 반작용으로 나온 것이다
  - 디자인패턴에 익숙하다면 이 리팩터링을 '서브클래스를 상태 패턴'이나 '전략 패턴'으로 대체한다고 생각하면 도움이 된다
- 서브클래스를 위임으로 바꾸는 모든 경우에서 위임을 계층구조로 설계해야 하는 건 아니다
  - 하지만 상태나 전략에 계층구조를 적용하면 유용할 때가 많다 (🤔)
```
<br/>


---
## 목차
- [12.1 메서드 올리기](#121-메서드-올리기)
- [12.2 필드 올리기](#122-필드-올리기)
- [12.3 생성자 본문 올리기](#123-생성자-본문-올리기)
- [12.4 메서드 내리기](#124-메서드-내리기)
- [12.5 필드 내리기](#125-필드-내리기)
- [12.6 타입 코드를 서브클래스로 바꾸기](#126-타입-코드를-서브클래스로-바꾸기)
- [12.7 서브 클래스 제거하기](#127-서브클래스-제거하기)
- [12.8 슈퍼 클래스 추출하기](#128-슈퍼클래스-추출하기)
- [12.9 계층 합치기](#129-계층-합치기)
- [12.10 서브 클래스를 위임으로 바꾸기](#1210-서브-클래스를-위임으로-바꾸기)
- [12.11 슈퍼 클래스를 위임으로 바꾸기](#1211-슈퍼-클래스를-위임으로-바꾸기)

<br/>

### 12.1 메서드 올리기
- 카탈로그: [Pull Up Method](https://refactoring.com/catalog/pullUpMethod.html)
- 반대 리팩터링: [메서드 내리기](#124-메서드-내리기)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch12/ex1)
  - [테스트](../src/test/java/com/example/refactoring2/ch12/ex1)

<br/>

**배경**
- 중복 코드 제거는 중요하다
- 무언가 중복되었다는 것은 한쪽의 변경이 다른 쪽에는 반영되지 않을 수 있다는 위험을 항상 수련한다
- 메서드 올리기를 적용하기 가장 쉬운 상황은 메서드들의 본문 코드가 똑같을 때다
<br/>

**절차**
- 똑같이 동작하는 메서드인지 면밀히 살펴본다
  - 실질적으로 하는 일은 같지만 코드가 다르다면 본문 코드가 똑같아질 때까지 리팩터링한다
- 메서드 안에서 호출하는 다른 메서드와 참조하는 필드들을 슈퍼클래스에서도 호출하고 참할 수 있는지 확인한다
- 메서드 시그니처가 다르다면 함수 선언 바꾸기로 슈퍼클래스에서 사용하고 싶은 형태로 통일한다
- 슈퍼클래스에 새로운 메서드를 생성하고, 대상 메서드의 코드를 복사해넣는다
- 정적 검사를 수행한다
- 서브클래스 중 하나의 메서드를 제거한다
- 테스트한다
- 모든 서브클래스의 메서드가 없어질 때까지 다른 서브클래스의 메서드를 하나씩 제거한다
<br/>

**💩before**
```java
public class Party {
}

public class Department extends Party {

    private final int monthlyCost;

    public Department(int monthlyCost) {
        this.monthlyCost = monthlyCost;
    }

    public int getTotalAnnualCost() {
        return this.monthlyCost * 12;
    }
}

public class Employee extends Party {
  private final int monthlyCost;

  public Employee(int monthlyCost) {
    this.monthlyCost = monthlyCost;
  }

  public int annualCost() {
    return this.monthlyCost * 12;
  }
}
```
<br/>

**✨after**
```java
public abstract class Party {
  public int annualCost() {
    throw new IllegalStateException();
  }
}

public class Employee extends Party {
    private final int monthlyCost;

    public Employee(int monthlyCost) {
        this.monthlyCost = monthlyCost;
    }

    @Override
    public int annualCost() {
        return this.monthlyCost * 12;
    }
}

public class Department extends Party {

  private final int monthlyCost;

  public Department(int monthlyCost) {
    this.monthlyCost = monthlyCost;
  }

  @Override
  public int annualCost() {
    return this.monthlyCost * 12;
  }
}
```
<br/>


### 12.2 필드 올리기
- 카탈로그: [Pull Up Field](https://refactoring.com/catalog/pullUpField.html)
- 반대 리팩터링: [필드 내리기](#125-필드-내리기)
- 예시 ❌

<br/>

**배경**
- 특히 필드가 중복되기 쉽다
- 그래서 어떤 일이 벌어지는지를 알아내려면 필드들이 어떻게 이용되는 분석해봐야 한다
<br/>

**절차**
- 후보 필드들을 사용하는 곳 모두가 그 필드들을 똑같은 방식으로 사용하는지 면밀히 살핀다
- 필드들의 이름이 각기 다르다면 똑같은 이름으로 바꾼다
- 슈퍼클래스에 새로운 필드를 생성한다
  - 서브클래스에서 이 필드에 접근할 수 있어야 한다
- 서브클래스의 필드들을 제거한다
- 테스트한다
<br/>


**💩before**
```java
class Employee {..}

class Salesperson extends Employee {
    private String name;
}

class Engineer extends Employee {
  private String name;
}
```
<br/>

**✨after**
```java
class Employee {
  private String name;
}

class Salesperson extends Employee {
}

class Engineer extends Employee {
}
```
<br/>


### 12.3 생성자 본문 올리기
- 카탈로그: [Pull Up Constructor Body](https://refactoring.com/catalog/pullUpConstructorBody.html)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch12/ex3)
  - [테스트](../src/test/java/com/example/refactoring2/ch12/ex3)

<br/>

**배경**
- 서브클래스들에서 기능이 같은 메서드들을 발견하면 함수 추출하기와 메서드 올리기를 차례로 적용하여 말끔히 슈퍼클래스로 옮기곤한다
<br/>

> **NOTE** 이번 리팩터링이 간단히 끝날 것 같지 않다면 생성자를 팩터리 함수로 바꾸기를 고려한다

**절차**
- 슈퍼클래스에 생성자가 없다면 하나 정의한다. 서브클래스의 생성자들에서 이 생성자가 호출되는지 혹인한다
- 문장 슬라이드하기로 공통 문장 모두를 super() 호출 직후로 옮긴다
- 공통 코드를 슈퍼클래스에 추가하고 서브클래스들에서는 제거한다
  - 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 super()로 건넨다
- 테스트한다
- 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 함수 추출하기와 메서드 올리기를 차례로 적용한다
<br/>

**💩before**
```java
public class Party {
}

public class Employee extends Party {
  private final Long id;
  private final String name;
  private final int monthlyCost;

  public Employee(Long id, String name, int monthlyCost) {
    super();
    this.id = id;
    this.name = name;
    this.monthlyCost = monthlyCost;
  }
}

public class Department extends Party {
    private final String name;
    private final String staff;

    public Department(String name, String staff) {
        super();
        this.name = name;
        this.staff = staff;
    }
}


```
<br/>

**✨after**
```java
public class Party {
    private final String name;

    protected Party(String name) {
        this.name = name;
    }
}

public class Employee extends Party {
  private final Long id;
  private final int monthlyCost;

  public Employee(Long id, String name, int monthlyCost) {
    super(name);
    this.id = id;
    this.monthlyCost = monthlyCost;
  }
  
  // ..
}

public class Department extends Party {
  private final String staff;

  public Department(String name, String staff) {
    super(name);
    this.staff = staff;
  }
    
  //.. 
}
```
- (두 번째 예시는 생략) 생성자에서 추가 작업하는 내용이 서브 클래스 공통으로 있으면 슈퍼 클래스에 옮길 수 있다는 내용
<br/>


### 12.4 메서드 내리기
- 카탈로그: [Push Down Method](https://refactoring.com/catalog/pushDownMethod.html)
- 반대 리팩터링: [메서드 올리기](#121-메서드-올리기)
- 예시 ❌

<br/>

**배경**
- 특정 서브클래스 하나(혹은 소수)와만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브클래스(들)에 추가하는 편이 깔끔하다
<br/>

**절차**
- 대상 메서드를 모든 서브클래스에 복사한다
- 슈퍼클래스에서 그 메서드를 제거한다
- 테스트한다
- 이 메서드를 사용하지 않는 모든 서브클래스에서 제거한다
- 테스트한다
<br/>

**💩before**
```java
public class Employee {
    public int quota { //.. }
}

class Engineer extends Employee {
  //..
}

class Salesperson extends Employee {
  //..
}
```
<br/>

**✨after**
```java
public class Employee {
    //.. 
}

class Engineer extends Employee {
  //..
}

class Salesperson extends Employee {
  public int quota { //.. }
}
```
<br/>


### 12.5 필드 내리기
- 카탈로그: [Push Down Field](https://refactoring.com/catalog/pushDownField.html)
- 반대 리팩터링: [필드 올리기](#122-필드-올리기)
- 예시 ❌

<br/>

**배경**
- 서브클래스 하나(혹은 소수)에서만 사용하는 필드는 해당 서브클래스(들)로 옮긴다
<br/>

**절차**
- 대상 필드를 모든 서브클래스에 정의한다
- 슈퍼클래스에서 그 필드를 제거한다
- 테스트한다
- 이 필드를 사용하지 않는 모든 서브클래스에서 제거한다
- 테스트한다
<br/>

**💩before**
```java
public class Employee {
    private String quota;
}

class Engineer extends Employee {
  //..
}

class Salesperson extends Employee { 
  //..
}
```
<br/>

**✨after**
```java
public class Employee {
    
}

class Engineer extends Employee {
  //..
}

class Salesperson extends Employee {
  protected String quota;
}
```
<br/>


### 12.6 타입 코드를 서브클래스로 바꾸기
- 카탈로그: [Replace Type Code with Subclasses](https://refactoring.com/catalog/replaceTypeCodeWithSubclasses.html)
- 반대 리팩터링: [서브 클래스 제거하기](#127-서브클래스-제거하기)
- 하위 리팩터링: 타입 코드를 상태/전략 패턴으로 바꾸기, 서브 클래스 추출하기
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch12/ex6)
  - [테스트](../src/test/java/com/example/refactoring2/ch12/ex6)

<br/>

**배경**
- 소프트웨어 시스템에서는 비슷한 대상들을 특정 특성에 따라 구분해야 할 때가 자주 있다
  - 예컨대 직원을 `담당 업무(엔지니어, 관리자, 영업자 등)`로 구분하거나 주문을 `시급성(급함, 보통 등)`으로 구분하기도 한다
- 이런 일을 다루는 수단으로는 **타입 코드 필드**가 있다
  - 프로그래밍 언어에 따라 열거형이나 심볼, 문자열, 숫자 등으로 표현하며, 외부 서비스가 제공하는 데이터를 다루려 할 때 딸려오는 일이 흔하다
- 타입 코드만으로 부족해 무언가 필요할 때 **서브클래스**를 사용할 수도 있다
- 서브클래스는 두 가지 면에서 특히 매력적이다
  - 첫째, 조건에 따라 다르게 동작하도록 해주는 다형성을 제공한다
  - 둘째, 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때 발현된다
<br/>

**절차**
- 타입 코드 필드를 자가 캡슐화한다
- 타입 코드 값 하나를 선택하여 그 값에 해당하는 서브클래스를 만든다
  - 타입 코드 게터 메서드를 오버라이드하여 해당 타입 코드의 리터럴 값을 반환하게 한다
- 매개변수로 받은 타입 코드와 방금 만든 서브클래스를 매핑하는 선택 로직을 만든다
- 테스트한다
- 타입 코드 값 각각에 대해 서브클래스 생성과 선택 로직 추가를 반복한다
  - 클래스 하나가 완성될때마다 테스트한다
- 타입 코드 필드를 제거한다
- 테스트한다
- 타입 코드 접근자를 이용하는 메서드 모두에 메서드 내리기와 조건부 로직을 다형성으로 바꾸기를 적용한다 
<br/>

**💩before**
```java
public class Employee {
  private static final Set<String> types = Set.of("engineer", "manager", "salesperson");

  private final String name;
  private final String type;

  public Employee(String name, String type) {
    validateType(type);
    this.name = name;
    this.type = type;
  }

  public void validateType(String type) {
    if (!types.contains(type)) {
      throw new IllegalArgumentException(type + "라는 직원 유형은 없습니다.");
    }
  }
}
```
<br/>

**✨after**
```java
public class Employee {
  private final String name;

  public Employee(String name) {
    this.name = name;
  }

  public static Employee of(String name, String type) {
    return switch (type) {
      case "engineer" -> new Engineer(name);
      case "manager" -> new Manager(name);
      case "salesperson" -> new Salesperson(name);
      default -> throw new IllegalArgumentException(type + "라는 직원 유형은 없습니다");
    };
  }
  
  // .. 
}

public class Salesperson extends Employee {
  public Salesperson(String name) {
    super(name);
  }
}

// 이하 생략
```
<br/>

두번째 예시
```java
public class Employee2 {
  private static final Set<String> types = Set.of("engineer", "manager", "salesperson");

  private final String name;
  private final String type;

  public Employee2(String name, String type) {
    validateType(type);
    this.name = name;
    this.type = type;
  }

  public void validateType(String type) {
    if (!types.contains(type)) {
      throw new IllegalArgumentException(type + "라는 직원 유형은 없습니다.");
    }
  }

  public String capitalizedType() {
    char first = type.charAt(0);
    return Character.toUpperCase(first) + type.substring(1).toLowerCase();
  }

  public String toString() {
    return String.format("%s (%s)", this.name, this.type);
  }
}
```

생성자에서는 `this.type = type` 선언하고 getter/setter 에서는 `this._type`을 사용해서 혼란이 왔는데 
- 자바스크립트에서 `this.type = type`를 선언하면 `set type(...)` 호출되는 것과 같다함
- `this._type`은 내부 필드이고, `this.type`은 getter 호출되는 것과 같다함

결국 값 객체로 포장해서 가지나보다

```java
public class Employee2 {
  private final String name;
  private final EmployeeType employeeType;

  public Employee2(String name, String type) {
    this(name, createEmployeeType(type));
  }

  public Employee2(String name, EmployeeType employeeType) {
    this.name = name;
    this.employeeType = employeeType;
  }

  public static EmployeeType createEmployeeType(String type) {
    return switch (type) {
      case "engineer" -> new Engineer();
      case "manager" -> new Manager();
      case "salesperson" -> new Salesperson();
      default -> throw new IllegalArgumentException("Invalid type " + type);
    };
  }

  public String capitalizedType() {
    char first = this.typeString().charAt(0);
    return Character.toUpperCase(first) + this.typeString().substring(1).toLowerCase();
  }

  public String toString() {
    return String.format("%s (%s)", this.name, this.typeString());
  }

  public EmployeeType getType() {
    return employeeType;
  }

  public String typeString() {
    return employeeType.toString();
  }
  
  // equals, hashCode
}


public abstract class EmployeeType {
  @Override
  public boolean equals(Object obj) {
    return obj != null && this.getClass() == obj.getClass();
  }

  @Override
  public int hashCode() {
    return getClass().hashCode();
  }
}


public class Manager extends EmployeeType {
  @Override
  public String toString() {
    return "manager";
  }
}

// 이하 생략
```


### 12.7 서브클래스 제거하기
- 카탈로그: [Remove Subclass](https://refactoring.com/catalog/removeSubclass.html)
- 반대 리팩터링: [타입 코드를 서브 클래스로 바꾸기](#126-타입-코드를-서브클래스로-바꾸기)
- 1판에서의 이름: 하위클래스를 필드로 전환
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch12/ex7)
  - [테스트](../src/test/java/com/example/refactoring2/ch12/ex7)

<br/>

**배경**
- 서브클래싱은 원래 데이터 구조와는 다른 변종을 만들거나 종류에 따라 동작이 달라지게 할 수 있는 유용한 메커니즘이다
- 하지만 소프트웨어 시스템이 성장함에 따라 서브클래스로 만든 변종이 다른 모듈로 이동하거나 완전히 사라지기도 하면서 가치가 바래기도 한다
- 서브클래스는 결국 한 번도 활용되지 않기도 하며, 때론 서브클래스를 필요로 하지 않는 방식으로 만들어진 기능에서만 쓰이기도 한다
<br/>

**절차**
- 서브클래스의 생성자를 팩터리 함수로 바꾼다
  - 생성자를 사용하는 측에서 데이터 필드를 이용해 어떤 서브클래스를 생성할지 결정한다면 로직을 슈퍼클래스의 팩터리 메서드에 넣는다
- 서브클래스의 타입을 검사하는 코드가 있다면 그 검사 코드에 함수 추출하기와 함수 옮기기를 차례로 적용하여 슈퍼클래스로 옮긴다
  - 하나 변경할 때마다 테스트한다
- 서브클래스의 타입을 나타내는 필드를 슈퍼클래스에 만든다
- 서브클래스를 참조하는 메서드가 방금 만든 타입 필드를 이용하도록 수정한다
- 서브클래스를 지운다
- 테스트한다
<br/>

**💩before**
```java
public class Person {
  private final String name;

  public Person(String name) {
    this.name = name;
  }

  public String genderCode() {
    return "X";
  }
}


public class Male extends Person {
  public Male(String name) {
    super(name);
  }

  @Override
  public String genderCode() {
    return "M";
  }
}

public class Female extends Person {
  public Female(String name) {
    super(name);
  }

  @Override
  public String genderCode() {
    return "F";
  }
}

```
<br/>

무언가의 표현 방법을 바꾸려 할 때면 먼저 현재의 표현을 캡슐화하여 이 변화가 클라이언트 코드에 주는 영향을 최소화한다


**✨after**
```java
public class Person {
  private final String name;
  private final String genderCode;

  public Person(String name, String genderCode) {
    this.name = name;
    this.genderCode = StringUtils.hasLength(genderCode) ? genderCode : "X";
  }

  public static Person from(String name, String gender) {
    return switch (gender) {
      case "M" -> new Male(name, "M");
      case "F" -> new Female(name, "F");
      default -> new Person(name, "X");
    };
  }

  public static List<Person> loadFromInput(String[][] data) {
    return Stream.of(data).map(aRecord -> from(aRecord[0], aRecord[1])).toList();
  }

  public String genderCode() {
    return this.genderCode;
  }

  public boolean isMale() {
    return this.genderCode.equals("M");
  }
  
  // equals, hashCode
}

public class Male extends Person {
  public Male(String name, String genderCode) {
    super(name, genderCode);
  }
}
```
<br/>


### 12.8 슈퍼클래스 추출하기
- 카탈로그: [Extract Superclass](https://refactoring.com/catalog/extractSuperclass.html)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch12/ex8)
  - [테스트](../src/test/java/com/example/refactoring2/ch12/ex8)

<br/>

**배경**
- 비슷한 일을 수행하는 두 클래스가 보이면 상속 매커니즘을 이용해서 비슷한 부분을 공통의 슈퍼클래스로 옮겨 담을 수 있다
- 공통된 부분이 데이터라면 필드 올리기를 활용하고 동작이라면 메서드 올리기를 활용하면 된다
- 저자는 `상속은 프로그램이 성장하면서 깨우쳐가게 되며, 슈퍼클래스로 끌어올리고 싶은 공통 요소를 찾았을 때 수행하는 사례가 잦았다`고 말한다
- 슈퍼클래스 추출하기 대안으로는 클래스 추출하기가 있다
- 어느 것을 선택하느냐는 중복 동작을 상속으로 해결하느냐 위임으로 해결하느냐에 달렸다
- 슈퍼클래스 추출하기 방법이 더 간단할 경우가 많으니 이 리팩터링을 먼저 시도해보길 권한다
  - 나중에라도 필요해지면 슈퍼클래스를 위임으로 바꾸기(12.11)는 어렵지 않다
<br/>

**절차**
- 빈 슈퍼클래스를 만든다. 원래의 클래스들이 새 클래스를 상속하도록 한다
  - 필요하다면 생성자에 함수 선언 바꾸기를 적용한다
- 테스트한다 
- 생성자 본문 올리기, 메서드 올리기, 필드 올리기를 차례로 적용하여 공통 원소를 클래스로 옮긴다
- 서브클래스에 남은 메서드들을 검토한다. 공통되는 부분이 있다면 함수로 추출한 다음 메서드 올리기를 적용한다
- 원래 클래스들을 사용하는 코드를 검토하여 슈퍼클래스의 인터페이스를 사용하게 할지 고민해본다
<br/>

**💩before**
```java
public class Employee {
  private final Long id;
  private final String name;
  private final int monthlyCost;

  public Employee(Long id, String name, int monthlyCost) {
    this.id = id;
    this.name = name;
    this.monthlyCost = monthlyCost; // 월간 비용
  }

  public long annualCost() { // 연간비용
    return this.monthlyCost * 12L;
  }

  public Long getId() {
    return id;
  }

  public String getName() {
    return name;
  }

  public int getMonthlyCost() {
    return monthlyCost;
  }
}


public class Department {
  private final String name;
  private final List<Integer> staff;

  public Department(String name, List<Integer> staff) {
    this.name = name;
    this.staff = new ArrayList<>(staff);
  }

  public long totalMonthlyCost() {
    return this.staff.stream().reduce(0, (sum, cost) -> sum + cost);
  }

  public int headCount() {
    return this.staff.size();
  }

  public long totalAnnualCost() {
    return this.totalMonthlyCost() * 12;
  }

  public String getName() {
    return name;
  }

  public List<Integer> getStaff() {
    return Collections.unmodifiableList(staff);
  }
}
```
<br/>

**✨after**
```java
public abstract class Party {
  protected final String name;

  protected Party(String name) {
    this.name = name;
  }

  public String getName() {
    return name;
  }

  public long annualCost() {
    return monthlyCost() * 12L;
  }

  abstract long monthlyCost();
}


public class Employee extends Party {
  private final Long id;
  private final int monthlyCost;

  public Employee(Long id, String name, int monthlyCost) {
    super(name);
    this.id = id;
    this.monthlyCost = monthlyCost;
  }

  @Override
  public long monthlyCost() {
    return monthlyCost;
  }
}


public class Department extends Party {
  private final List<Integer> staff;

  public Department(String name, List<Integer> staff) {
    super(name);
    this.staff = new ArrayList<>(staff);
  }

  @Override
  public long monthlyCost() {
    return this.staff.stream().reduce(0, (sum, cost) -> sum + cost);
  }

  public int headCount() {
    return this.staff.size();
  }

  public List<Integer> getStaff() {
    return Collections.unmodifiableList(staff);
  }
}
```
<br/>


### 12.9 계층 합치기
- 카탈로그: [Collapse Hierarchy](https://refactoring.com/catalog/collapseHierarchy.html)
- 예시 ❌

<br/>

**배경**
- 예컨대 계층구조도 진화하면서 어떤 클래스와 그 부모가 너무 비슷해져서 더는 독립적으로 존재해야 할 이유가 사라지는 경우가 생기기도 한다
<br/>

**절차**
- 두 클래스 중 제거할 것을 고른다
  - 미래를 생각하여 더 적합한 이름의 클래스를 남기자
  - 둘 다 적절히 않다면 임의로 하나를 고른다
- 필드 올리기와 메서드 올리기 혹은 필드 내리기와 메서드 내리기를 적용하여 모든 요소를 하나의 클래스로 옮긴다
- 제거할 클래스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 고친다
- 빈 클래스를 제거한다
- 테스트한다
<br/>

**💩before**
```java
class Employee {...}

class Salesperson extends Employee {..}
```
<br/>

**✨after**
```java
class Employee {...}
```
<br/>


### 12.10 서브 클래스를 위임으로 바꾸기
- 카탈로그: [Replace Subclass with Delegate](https://refactoring.com/catalog/replaceSubclassWithDelegate.html)
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch12/ex10)
  - [테스트](../src/test/java/com/example/refactoring2/ch12/ex10)

<br/>

**배경**
- 속한 갈래에 따라 동작이 달라지는 객체들을 **상속**으로 표현하는 게 자연스럽다
- 공통 데이터와 동작은 모두 슈퍼클래스에 두고 서브클래스는 자신에 맞게 기능을 추가하거나 오버라이드하면 된다
- 하지만 상속에는 단점이 있다
  - 가장 명확한 단점은 한 번만 쓸 수 있는 카드라는 것이다
  - 또 다른 문제는 상속은 클래스들의 관계를 아주 긴밀하게 결합한다 (커플링, 부모 메서드를 자식이 다 아니 캡슐화를 깨버리기도 쉽다)
    - 부모를 수정하면 이미 존재하는 자식들의 기능을 해치기가 쉽기 때문에 각별히 주의해야 한다
    - 그래서 자식들이 슈퍼클래스를 어떻게 상속해 쓰는지를 이해해야 한다
- `위임(delegate)`은 이상의 두 문제를 모두 해결해준다 
  - 즉, 상속보다 결합도가 훨씬 약한다
- 유명한 원칙 중 하나가 있다
  - `'(클래스) 상속 보다는 (객체) 컴포지션을 사용하라'`
  - 여기서 컴포지션(composition)은 사실상 위임과 같은 말이다
  - 위임을 알고 있다면 처음에 상속으로 접근한 다음, 문제가 생기면 위임으로 갈아탄다
- 디자인패턴 책은 상속과 컴포지션을 함께 사용하는 방법을 설명해준다
  - 이 원칙은 상속을 쓰지 말라는 게 아니라, 과용하는 데 따른 반작용으로 나온 것이다
  - 디자인패턴에 익숙하다면 이 리팩터링을 '서브클래스를 상태 패턴'이나 '전략 패턴'으로 대체한다고 생각하면 도움이 된다
- 서브클래스를 위임으로 바꾸는 모든 경우에서 위임을 계층구조로 설계해야 하는 건 아니다
  - 하지만 상태나 전략에 계층구조를 적용하면 유용할 때가 많다
<br/>

**절차**
- 생성자를 호출하는 곳이 많다면 생성자를 팩터리 함수로 바꾼다
- 위임으로 활용할 빈 클래스를 만든다
  - 이 클래스의 생성자는 서브클래스에 특화된 데이터를 전부 받아야 하며, 보통은 슈퍼클래스를 가리키는 역참조도 필요하다
- 위임을 저장할 필드를 슈퍼클래스에 추가한다
- 서브클래스 생성 코드를 수정하여 위임 인스턴스를 생성하고 위임 필드에 대입해 초기화한다
  - 이 작업은 팩터리 함수가 수행한다
  - 혹은 생성자가 정확한 위임 인스턴스를 생성할 수 있는게 확실하다면 생성자에서 수행할 수도 있다
- 서브클래스의 메서드 중 위임 클래스로 이동할 것을 고른다
- 함수 옮기기를 적용해 위임 클래스로 옮긴다
  - 원래 메서드에서 위임하는 코드는 지우지 않는다
  - 이 메서드가 사용하는 원소 중 위임으로 옮겨야 하는게 있다면 함께 옮긴다
  - 슈퍼클래스에 유지해야 할 원소를 참조한다면 슈퍼클래스를 참조하는 필드를 위임에 추가한다
- 서브클래스 외부에도 원래 메서드를 호출하는 코드가 있다면 서브클래스의 위임 코드를 슈퍼클래스로 옮긴다
  - 이때 위임이 존재하는지를 검사하는 보호 코드로 감싸야 한다
  - 호출하는 외부 코드가 없다면 원래 메서드는 죽은 코드가 되므로 제거한다 
  - 서브클래스가 둘 이상이고 서브클래스들에서 중복이 생겨나기 시작했따면 슈퍼클래스를 추출한다
  - 이렇게 하여 기본 동작이 위임 슈퍼클래스로 옮겨졌다면 슈퍼클래스의 위임 메서드들에는 보호코드가 필요없다
- 테스트한다
- 서브클래스의 모든 메서드가 옮겨질 때까지 (5~8) 과정을 반복한다
- 서브클래스들의 생성자를 호출하는 코드를 찾아서 슈퍼클래스의 생성자를 사용하도록 수정한다
- 테스트한다
- 서브클래스르 삭제한다 (죽은 코드 제거하기)
<br/>

**💩before** <br/>
예시1. 서브클래스가 하나 일때
```java
public class Booking {
    protected final Show show;
    protected final LocalDate date;
    protected final boolean peakDay; // 함수 내용없어서 생성자 주입 받도록 변경, 캡슐화가 필요하면 전략 패턴 고려가능

    protected Booking(Show show, LocalDate date, boolean peakDay) {
        this.show = show;
        this.date = date;
        this.peakDay = peakDay;
    }

    // 일반 예약은 공연 후 관객과의 대화시간(talkback)을 성수기가 아닐 때만 제공한다
    public boolean hasTalkback() {
        return this.show.isTalkback() && !peakDay;
    }

    public long basePrice() {
        long result = this.show.price();
        if (peakDay) {
            result += Math.round(result * 0.15);
        }
        return result;
    }
}


public class Show {
  private final long price;
  private final boolean talkback; // 마찬가지 hasOwnProperty는 JS에서만 지원해서 멤버 필드 선언

  public Show(long price, boolean talkback) {
    this.price = price;
    this.talkback = talkback;
  }

  public long price() {
    return this.price;
  }

  public boolean isTalkback() {
    return this.talkback;
  }
}


public class PremiumBooking extends Booking {
  private final Extras extras; // 추가 비용

  public PremiumBooking(Show show, LocalDate date, boolean peakDay, Extras extras) {
    super(show, date, peakDay);
    this.extras = extras;
  }

  // 프리미엄 예약은 항상 관객과의 대화 시간을 마련한다
  @Override
  public boolean hasTalkback() {
    return this.show.isTalkback();
  }

  @Override
  public long basePrice() {
    return Math.round(super.basePrice() + this.extras.premiumFee());
  }
}


public class Extras {

  private final long premiumFee;
  private final boolean dinner; // 마찬가지로 멤버 필드 선언

  public Extras(long premiumFee, boolean dinner) {
    this.premiumFee = premiumFee;
    this.dinner = dinner;
  }

  public long premiumFee() {
    return this.premiumFee;
  }

  public boolean hasDinner() {
    return this.dinner;
  }
}
```
<br/>

서브클래스를 위임으로 바꾸려할까?
- **상속은 한 번만 사용할 수 있는 도구다**
- 따라서 상속을 사용해야 할 다른 이유가 생긴다면, 그리고 그 이유가 프리미엄 예약 서브클래스보다 가치가 크다고 생각된다면 프리미엄 예약을 (상속이 아닌) 다른 방식으로 표현해야 할 것이다.
- 또한, 기본 예약에서 프리미엄 예약으로 동적으로 전환할 수 있도록 해야 할 수도 있다.


```java
public class PremiumDelegate {
  private final Booking host;
  private final Extras extras;

  public premiumDelegate(Booking host, Extras extras) {
    this.host = host;
    this.extras = extras;
  }
}

```
<br/>

 
```javascript
_bePremium(extras) {
  this._premiumDelegate = new premiumDelegate(this, extras);
}
```
- 여기서 `_bePremium`은 공개(public) 메서드지만, 앞에 언더바 `_` 를 붙여서 "이건 내부에서만 써야 해요!"라는 관례적인 신호를 주는 거예요.
- 즉, 프라이빗은 아니지만, 프라이빗처럼 써주세요~ 라는 뜻이에요.
- 자바스크립트에서는 진짜 private 키워드가 없던 시절이 길었기 때문에 `_`로 구분하는 관례가 있었습니다.
- 하지만 <u>자바에서는 접근 제어자가 명시적이기 때문에 더 명확하게 해야 해요.</u>


PremiumBooking의 hasTalkback()를 위임한다
```java
public class Booking {
  protected final Show show;
  protected final LocalDate date;
  protected final boolean peakDay;

  protected PremiumDelegate premiumDelegate; // 접근 제어자를 protected로 변경

  protected Booking(Show show, LocalDate date, boolean peakDay) {
    this.show = show;
    this.date = date;
    this.peakDay = peakDay;
  }


  public static Booking createBooking(Show show, LocalDate date, boolean peakDay) {
    return new Booking(show, date, peakDay);
  }

  public static PremiumBooking createPremiumBooking(Show show, LocalDate date, boolean peakDay, Extras extras) {
    PremiumBooking result = new PremiumBooking(show, date, peakDay, extras);
    result.bePremium(extras);
    return result;
  }

  protected void bePremium(Extras extras) { // 마찬가지로 접근 제어자를 protected로 변경
    this.premiumDelegate = new PremiumDelegate(this, extras);
  }
  
  // 이하 생략
}


public class PremiumDelegate {
  private final Booking host;
  private final Extras extras;

  public PremiumDelegate(Booking host, Extras extras) {
    this.host = host;
    this.extras = extras;
  }

  public boolean hasTalkback() {
    Show show = this.host.getShow();
    return show.isTalkback();
  }
}


public class PremiumBooking extends Booking {
  private final Extras extras; // 추가 비용

  public PremiumBooking(Show show, LocalDate date, boolean peakDay, Extras extras) {
    super(show, date, peakDay);
    this.extras = extras;
  }

  @Override
  public boolean hasTalkback() {
    return this.premiumDelegate.hasTalkback(); // 테스트 후 삭제한다 (🗑)️
  }

  @Override
  public long basePrice() {
    return Math.round(super.basePrice() + this.extras.premiumFee());
  }
}


public class Booking {
    
  //.. 

  public boolean hasTalkback() {
    return (this.premiumDelegate != null)
            ? this.premiumDelegate.hasTalkback()
            : this.show.isTalkback() && !peakDay;
  }
    
}
```

basePrice()를 위임한다. 그런데 PrimiumBooking에 basePrice()를 그대로 옮기고, Book의 basePrice()를 호출하면 무한 재귀에 빠진다
```java
public class Book {
  public long basePrice() {
    return (this.premiumDelegate != null)
            ? this.premiumDelegate.basePrice()
            : this.privateBasePrice();
  }
}


public class PremiumDelegate {
  private final Booking host;
  private final Extras extras;

  public PremiumDelegate(Booking host, Extras extras) {
    this.host = host;
    this.extras = extras;
  }

  public boolean hasTalkback() {
    Show show = this.host.getShow();
    return show.isTalkback();
  }

  public long basePrice() {
    return Math.round(this.host.basePrice() + this.extras.premiumFee()); // super 대신, this.host 호출
  }
}

```
<br/>

방법은 두 가지이다. 첫 번째는 슈퍼클래스의 계산 로직을 함수로 추출하여 가격 계산과 분배 로직을 분리하는 것이다.
```java
public class Booking {
  public long basePrice() {
    return (this.premiumDelegate != null)
            ? this.premiumDelegate.basePrice()
            : this.privateBasePrice();
  }

  protected long privateBasePrice() {
    long result = this.show.price();
    if (peakDay) {
      result += Math.round(result * 0.15);
    }
    return result;
  }
}


public class PremiumDelegate {
  public long basePrice() {
    return Math.round(this.host.privateBasePrice() + this.extras.premiumFee());
  }
}
```

둘째, 위임 메서드를 기반 메서드의 확장 형태로 재호출한다 
- 개인적으로도 두 번째가 선호된다
- 왜냐하면 슈퍼클래스에 메서드를 호출하는 것보다 위임 클래스에 basePrice 전달하는게 테스트하기도 쉬운거 같다

```java

public class Book {
  public long basePrice() {
    long result = this.show.price();
    if (peakDay) {
      result += Math.round(result * 0.15);
    }
    return (this.premiumDelegate != null)
            ? this.premiumDelegate.extendBasePrice(result)
            : result;
  }
}

public class PremiumDelegate {
  public long extendBasePrice(long basePrice) {
    return basePrice + this.extras.premiumFee();
  }
}
```
<br/>

마지막으로 서브클래스에만 존재하는 메서드도 있을 것이다
```java
public class PremiumBooking {
  public boolean hasDinner() {
    return this.extras.hasDinner() && !this.peakDay;
  }
}

public class PremiumDelegate {
  public boolean hasDinner() {
    return this.extras.hasDinner() && !this.host.peakDay;
  }
}

public class Booking {
  public boolean hasDinner() {
    return (this.premiumDelegate != null)
            && this.premiumDelegate.hasDinner();
  }
}
```
<br/>

서브클래스의 동작을 모두 옮겼다면 팩터리 메서드가 슈퍼클래스를 반환하도록 수정한다. 
테스트 후 필요없어진 서브클래스(`PremiumBooking`)를 지운다
```java
public class Booking {
  public static Booking createPremiumBooking(Show show, LocalDate date, boolean peakDay, Extras extras) {
    Booking result = new Booking(show, date, peakDay);
    result.bePremium(extras);
    return result;
  }

  protected void bePremium(Extras extras) {
    this.premiumDelegate = new PremiumDelegate(this, extras);
  }
}
```

> 아! 상속하는 서브클래스가 하나 일때 위임으로 옮겨서 상속을 다른 유용한 용도로 사용할 수 있게 하는 과정이었구나.
> PremiumDelegate 클래스에 PremiumBookd에서 필요한 속성과 행위를 옮긴다. 
> Booking에서는 PremiumDelegate != null 인 경우 조건을 처리하는 방식으로 서브클래스 제거 가능했다.

**✨after**
```java
public class Booking {
    protected final Show show;
    protected final LocalDate date;
    protected final boolean peakDay;

    protected PremiumDelegate premiumDelegate;

    protected Booking(Show show, LocalDate date, boolean peakDay) {
        this.show = show;
        this.date = date;
        this.peakDay = peakDay;
    }

    public static Booking createBooking(Show show, LocalDate date, boolean peakDay) {
        return new Booking(show, date, peakDay);
    }

    public static Booking createPremiumBooking(Show show, LocalDate date, boolean peakDay, Extras extras) {
        Booking result = new Booking(show, date, peakDay);
        result.bePremium(extras);
        return result;
    }

    protected void bePremium(Extras extras) {
        this.premiumDelegate = new PremiumDelegate(this, extras);
    }

    public boolean hasTalkback() {
        return (this.premiumDelegate != null)
                ? this.premiumDelegate.hasTalkback()
                : this.show.isTalkback() && !peakDay;
    }

    public long basePrice() {
        long result = this.show.price();
        if (peakDay) result += Math.round(result * 0.15);

        return (this.premiumDelegate != null)
                ? this.premiumDelegate.extendBasePrice(result)
                : result;
    }

    public boolean hasDinner() {
        return (this.premiumDelegate != null)
                && this.premiumDelegate.hasDinner();
    }

    public Show getShow() {
        return show;
    }
}


public class Extras {

  private final long premiumFee;
  private final boolean dinner;

  public Extras(long premiumFee, boolean dinner) {
    this.premiumFee = premiumFee;
    this.dinner = dinner;
  }

  public long premiumFee() {
    return this.premiumFee;
  }

  public boolean hasDinner() {
    return this.dinner;
  }
}


public class Show {
  private final long price;
  private final boolean talkback;

  public Show(long price, boolean talkback) {
    this.price = price;
    this.talkback = talkback;
  }

  public long price() {
    return this.price;
  }

  public boolean isTalkback() {
    return this.talkback;
  }
}


public class PremiumDelegate {
  private final Booking host;
  private final Extras extras;

  public PremiumDelegate(Booking host, Extras extras) {
    this.host = host;
    this.extras = extras;
  }

  public boolean hasTalkback() {
    Show show = this.host.getShow();
    return show.isTalkback();
  }

  public long extendBasePrice(long basePrice) {
    return basePrice + this.extras.premiumFee();
  }

  public boolean hasDinner() {
    return this.extras.hasDinner() && !this.host.peakDay;
  }
}

```
<br/>

**💩before**
두번째 예시
- 이 코드는 야생 조류와 사육 조류를 구분 짓기 위해 크게 수정할 예정이다
- 이 차이는 WildBird와 CaptiveBird라는 두 서브클래스로 모델링하는 방법도 있다
- <u>하지만 상속은 한번만 쓸 수 있으니 야생과 사육의 기준으로 나누려면 종에 따른 분류를 포기해야 한다</u>
```java
public class Bird {
  protected final String name;
  protected final String plumage;

  public Bird(String name, String plumage) {
    this.name = name;
    this.plumage = plumage;
  }

  public static Bird from(BirdDto birdDto) {
    return switch (birdDto.type()) {
      case "유럽 제비" -> new EuropeanSwallow(birdDto);
      case "아프리카 제비" -> new AfricanSwallow(birdDto);
      case "노르웨이 파랑 앵무" -> new NorwegianBlueParrot(birdDto);
      default -> throw new IllegalArgumentException(birdDto.type());
    };
  }

  public String name() {
    return name;
  }

  public String plumage() {
    return this.plumage.isBlank() ? "보통이다" : this.plumage;
  }

  public Integer airSpeedVelocity() {
    return null;
  }

}


public class AfricanSwallow extends Bird {
  private final int numberOfCoconuts;

  public AfricanSwallow(BirdDto data) {
    this(data.name(), data.plumage(), data.numberOfCoconuts());
  }

  public AfricanSwallow(String name, String plumage, int numberOfCoconuts) {
    super(name, plumage);
    this.numberOfCoconuts = numberOfCoconuts;
  }

  @Override
  public Integer airSpeedVelocity() {
    return 40 - 2 * numberOfCoconuts;
  }
}


public class EuropeanSwallow extends Bird {

  public EuropeanSwallow(BirdDto data) {
    this(data.name(), data.plumage());
  }

  public EuropeanSwallow(String name, String plumage) {
    super(name, plumage);
  }

  @Override
  public Integer airSpeedVelocity() {
    return 35;
  }
}


public class NorwegianBlueParrot extends Bird {
  private final int voltage;
  private final boolean isNailed;

  public NorwegianBlueParrot(BirdDto data) {
    this(data.name(), data.plumage(), data.voltage(), data.isNailed());
  }

  public NorwegianBlueParrot(String name, String plumage, int voltage, boolean isNailed) {
    super(name, plumage);
    this.voltage = voltage;
    this.isNailed = isNailed;
  }

  @Override
  public String plumage() {
    if (voltage > 100) return "그을렸다";

    return this.plumage.isBlank() ? "예쁘다" : this.plumage;
  }

  @Override
  public Integer airSpeedVelocity() {
    return isNailed ? 0 : 10 + voltage / 10;
  }
}

```
<br/>

```java
public class Bird {
  protected final String name;
  protected final String plumage;
  protected EuropeanSwallowDelegate speciesDelegate;

  public Bird(String name, String plumage) {
    this.name = name;
    this.plumage = plumage;
  }

  public Bird(BirdDto birdDto) {
    this.name = birdDto.name();
    this.plumage = birdDto.plumage();
    this.speciesDelegate = selectSpeciesDelegate(birdDto);
  }

  private static EuropeanSwallowDelegate selectSpeciesDelegate(BirdDto birdDto) {
    if (birdDto.type().equals("유럽 제비")) {
      return new EuropeanSwallowDelegate();
    }

    return null;
  }
  
  //.. 
}
```
- EuropeanSwallow 클래스에 있던 `airSpeedVelocity()`를 EuropeanSwallowDelegate 옮긴다
- EuropeanSwallow 클래스의 `airSpeedVelocity()`에서는 `speciesDelegate.airSpeedVelocity()` 호출한다
- Bird의 `airSpeedVelocity()` 조건문을 추가한다
- 정적 팩터리 메서드에서 EuropeanSwallow 조건절을 지우고 EuropeanSwallow 클래스를 삭제한다
  - 크게 보면 위임 클래스를 만들고, 위임 클래스에 필요한 메서드나 필드를 넘기고, 포워딩 호출, 그리고 제거 순이네

<br/>

```java
public class Bird {
    protected final String name;
    protected final String plumage;
    protected Object speciesDelegate;

    public Bird(String name, String plumage) {
        this.name = name;
        this.plumage = plumage;
    }

    public Bird(BirdDto birdDto) {
        this.name = birdDto.name();
        this.plumage = birdDto.plumage();
        this.speciesDelegate = selectSpeciesDelegate(birdDto);
    }

    private Object selectSpeciesDelegate(BirdDto birdDto) {
        return switch (birdDto.type()) {
            case "유럽 제비" -> new EuropeanSwallowDelegate();
            case "아프리카 제비" -> new AfricanSwallowDelegate(birdDto);
            case "노르웨이 파랑 앵무" -> new NorwegianBlueParrotDelegate(birdDto, this);
            default -> throw new IllegalArgumentException(birdDto.type());
        };
    }

    public String name() {
        return name;
    }

    public String plumage() {
        if (this.speciesDelegate instanceof NorwegianBlueParrotDelegate) {
            return ((NorwegianBlueParrotDelegate) this.speciesDelegate).plumage();
        }

        return this.plumage.isBlank() ? "보통이다" : this.plumage;
    }

    public Integer airSpeedVelocity() {
        if (this.speciesDelegate instanceof EuropeanSwallowDelegate) {
            return ((EuropeanSwallowDelegate) this.speciesDelegate).airSpeedVelocity();
        }

        if (this.speciesDelegate instanceof AfricanSwallowDelegate) {
            return ((AfricanSwallowDelegate) this.speciesDelegate).airSpeedVelocity();
        }

        if (this.speciesDelegate instanceof NorwegianBlueParrotDelegate) {
            return ((NorwegianBlueParrotDelegate) this.speciesDelegate).airSpeedVelocity();
        }

        return null;
    }

}


public class AfricanSwallowDelegate {
  private final int numberOfCoconuts;

  public AfricanSwallowDelegate(BirdDto data) {
    this.numberOfCoconuts = data.numberOfCoconuts();
  }

  public Integer airSpeedVelocity() {
    return 40 - 2 * numberOfCoconuts;
  }
}


public class EuropeanSwallowDelegate {
  public Integer airSpeedVelocity() {
    return 35;
  }
}


public class NorwegianBlueParrotDelegate {
  private final int voltage;
  private final boolean isNailed;
  private final Bird bird;

  public NorwegianBlueParrotDelegate(BirdDto data, Bird bird) {
    this.voltage = data.voltage();
    this.isNailed = data.isNailed();
    this.bird = bird;
  }

  public String plumage() {
    if (voltage > 100) return "그을렸다";

    return this.bird.plumage().isBlank() ? "예쁘다" : this.bird.plumage();
  }

  public Integer airSpeedVelocity() {
    return isNailed ? 0 : 10 + voltage / 10;
  }
}

```
- `instanceof`로 타입 체크를 한다거나, 특수한 `plumage()`를 가지고 있다보니 타입체크가 더 어려워진다 
- `SpeciesDelegate` 슈퍼클래스를 추출한다
<br/>

**✨after**
```java
public class Bird {
    protected final String name;
    protected final String plumage;
    protected SpeciesDelegate speciesDelegate;

    public Bird(String name, String plumage) {
        this.name = name;
        this.plumage = plumage;
    }

    public Bird(BirdDto birdDto) {
        this.name = birdDto.name();
        this.plumage = birdDto.plumage();
        this.speciesDelegate = selectSpeciesDelegate(birdDto);
    }

    private SpeciesDelegate selectSpeciesDelegate(BirdDto birdDto) {
        return switch (birdDto.type()) {
            case "유럽 제비" -> new EuropeanSwallowDelegate(this);
            case "아프리카 제비" -> new AfricanSwallowDelegate(birdDto, this);
            case "노르웨이 파랑 앵무" -> new NorwegianBlueParrotDelegate(birdDto, this);
            default -> new SpeciesDelegate(this);
        };
    }

    public static Bird from(BirdDto data) {
        return new Bird(data);
    }

    public String name() {
        return name;
    }

    public String plumage() {
        return this.speciesDelegate.plumage();
    }

    public Integer airSpeedVelocity() {
        return this.speciesDelegate.airSpeedVelocity();
    }

}


public class SpeciesDelegate {
  protected final Bird bird;

  protected SpeciesDelegate(Bird bird) {
    this.bird = bird;
  }

  public String plumage() {
    String plumage = this.bird.plumage();
    return plumage.isBlank() ? "보통이다" : plumage;
  }

  public Integer airSpeedVelocity() {
    return null;
  }
}


public class AfricanSwallowDelegate extends SpeciesDelegate {
  private final int numberOfCoconuts;

  public AfricanSwallowDelegate(BirdDto data, Bird bird) {
    super(bird);
    this.numberOfCoconuts = data.numberOfCoconuts();
  }

  @Override
  public Integer airSpeedVelocity() {
    return 40 - 2 * numberOfCoconuts;
  }
}


public class EuropeanSwallowDelegate extends SpeciesDelegate {

  public EuropeanSwallowDelegate(Bird bird) {
    super(bird);
  }

  @Override
  public Integer airSpeedVelocity() {
    return 35;
  }
}


public class NorwegianBlueParrotDelegate extends SpeciesDelegate {
  private final int voltage;
  private final boolean isNailed;

  public NorwegianBlueParrotDelegate(BirdDto data, Bird bird) {
    super(bird);
    this.voltage = data.voltage();
    this.isNailed = data.isNailed();
  }

  @Override
  public String plumage() {
    if (voltage > 100) return "그을렸다";

    return this.bird.plumage().isBlank() ? "예쁘다" : this.bird.plumage();
  }

  @Override
  public Integer airSpeedVelocity() {
    return isNailed ? 0 : 10 + voltage / 10;
  }
}
```

### 12.11 슈퍼 클래스를 위임으로 바꾸기
- 카탈로그: [Replace Superclass with Delegate](https://refactoring.com/catalog/replaceSuperclassWithDelegate.html)
- 1판에서의 이름: 상속을 위임으로 전환
- 바로가기:
  - [예시](../src/main/java/com/example/refactoring2/ch12/ex11)
  - [테스트](../src/test/java/com/example/refactoring2/ch12/ex11)

<br/>

**배경**
- 상속을 잘못 적용한 예로는 자바의 스택 클래스가 유명하다
  - 자바의 스택은 리스트를 상속하고 있는데, 데이터를 저장하고 조작하는 리스트의 기능을 재활용하겠다는 생각이 초래한 결과다
- 재활용이란 관점에서는 좋았지만 이 상속에는 문제가 있다
- 리스트의 연산 중 스택에는 적용되지 않는 게 많음에도 그 모든 연산이 스택 인터페이스에 그대로 노출되는 게 아닌가! 
- 이보다는 스택에서 리스트 객체를 필드에 저장해두고 필요한 기능만 위임했다면 더 멋졌을 것이다
- (..) 이상의 이유로 "상속은 절대 사용하지 말라"고 조언하는 사람도 있다. 나는 동의하지 않는다
- **의미상 적합한 조건이라면 상속은 간단하고 효과적인 매커니즘이다**
<br/>

**절차**
- 슈퍼클래스 객체를 참조하는 필드를 서브클래스에 만든다
  - 이번 리팩터링을 마치면 슈퍼클래스가 위임 객체가 될 것이므로 이 필드를 '위임 참조'라 부르자
  - 위임 참조를 새로운 슈퍼클래스 인스턴스로 초기화한다
- 슈퍼클래스의 동작 각각에 대응하는 전달 함수를 서브클래스에 만든다 (물론 위임 참조로 전달한다)
  - 서로 관련된 함수끼리 그룹으로 묶어 진행하며, 그룹을 하나씩 만들 때마다 테스트한다
  - 대부분은 전달 함수 각각을 테스트할 수 있을 것이다
  - 하지만 예컨대 게터와 세터 쌍은 둘 다 옮긴 후에야 테스트할 수 있다
- 슈퍼클래스의 동작 모두가 전달 함수로 오버라이드 되었다면 상속 관계를 끊는다
<br/>

**💩before**
```java
public class CatalogItem {
  protected final Long id;
  protected final String title;
  protected final Set<String> tags;

  public CatalogItem(Long id, String title, Set<String> tags) {
    this.id = id;
    this.title = title;
    this.tags = tags;
  }

  public Long getId() {
    return id;
  }

  public String getTitle() {
    return title;
  }

  public boolean hasTag(String tag) {
    return this.tags.contains(tag);
  }
}


public class Scroll extends CatalogItem {
    private final LocalDate lastCleaned;

    public Scroll(Long id, String title, Set<String> tags, LocalDate lastCleaned) {
        super(id, title, tags);
        this.lastCleaned = lastCleaned;
    }

    public boolean needsCleaning(LocalDate targetDate) {
        int threshold = this.hasTag("revered") ? 700 : 1500;
        return this.daysSinceLastCleaning(targetDate) > threshold;
    }

    // lastCleaned 부터 targetDate 까지 일 수 반환
    private long daysSinceLastCleaning(LocalDate targetDate) {
        return this.lastCleaned.until(targetDate, ChronoUnit.DAYS);
    }
}
```
<br/>

**✨after**
```java
public class CatalogItem {
  protected final Long id;
  protected final String title;
  protected final Set<String> tags;

  public CatalogItem(Long id, String title, Set<String> tags) {
    this.id = id;
    this.title = title;
    this.tags = tags;
  }

  public Long getId() {
    return id;
  }

  public String getTitle() {
    return title;
  }

  public boolean hasTag(String tag) {
    return this.tags.contains(tag);
  }
}

public class Scroll {
    private final LocalDate lastCleaned;
    private final CatalogItem catalogItem;

    public Scroll(Long id, String title, Set<String> tags, LocalDate lastCleaned) {
        this.catalogItem = new CatalogItem(id, title, tags);
        this.lastCleaned = lastCleaned;
    }

    public boolean needsCleaning(LocalDate targetDate) {
        int threshold = this.hasTag("revered") ? 700 : 1500;
        return this.daysSinceLastCleaning(targetDate) > threshold;
    }

    private long daysSinceLastCleaning(LocalDate targetDate) {
        return this.lastCleaned.until(targetDate, ChronoUnit.DAYS);
    }

    public Long id() {
        return this.catalogItem.id;
    }

    public String title() {
        return this.catalogItem.title;
    }

    public boolean hasTag(String tag) {
        return this.catalogItem.hasTag(tag);
    }
}
```
<br/>


---
### Reference.
