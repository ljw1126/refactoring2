# Chapter4. 테스트 구축하기

## 후기
이번 장에서 인상 깊었떤 문장은 "테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다." 였다.
예전에는 설계를 한다면 코드부터 작성하다 보니 책임 분리가 잘되지 않았고, 결국 유지보수하기 어려운 스파게티 코드가 되곤 했다. 
하지만 테스트를 먼저 작성해 보니, 객체가 어떤 속성과 동작을 가져야 할지 더 깊이 고민하게 되었고, 이 과정을 통해 책임 분리도 자연스럽게 이루어졌다. 덕분에 코드도 한층 더 명확하고 읽기 쉬워졌다.
이번 챕터를 통해 저자는 테스트 습관을 소개하고 있는데, 결과적으로 의식하고 연습하는 것이 중요하다는 사실을 한번 더 되새길 수 있었다.

```text
- 실패해야 할 상황에서 반드시 실패하게 만들자
- 완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는 게 낫다
- 리팩터링하기 가장 좋은 시점은 코드 베이스에 기능을 새로 추가하기 직전이다 (Chapter 2)
- 문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자
```

---
## 스터디 요약 (2/21 목요일)

**TDD 관련**
- TDD 리듬에 익숙해지는 최소한 1년은 거의 매일 훈련이 필요, 그렇지 않으면 잘하기 힘든 기술
- 테스트 만드는데 시간이 오래 걸림
    - 테스트를 원하는, 적절한 위치에서 만들지 못하는 경우가 대부분
        - 테스트를 만드는 훈련이 안 되어 있으면 초반에 99% 개발자가 전부 막힌다
    - 테스트를 잘못 만들면 구현 방법이 바뀌는 순간 테스트도 변경됨
        - 인터페이스를 테스트해야 하는데 구현을 테스트 하는 것은 좋지 않다
        - "테스트는 인터페이스를 테스트 하는 것!"
    - 방법을 찾아서 공부하고, 예제 연습해서 비슷한 경우에 적용해야 한다
- (중요*) 당연히 테스트도 리팩터링 하면서 같이 진행한다
- 좋은 점 or 중요한 부분
    - "테스트를 만들면 실패해야 한다"
    - 로직에 의해 실패하는걸 보고 성공하는 걸 본다 (단계 나누는 연습)
        - 컴파일 에러인지, 로직 에러인지
        - 무엇이 필요한지 인지하는 단계 필요
<br/>

**fixture 관련**
- 방법1. 직접 코드로 작성해 본다
    - 참고. [How to Create a Test Data Builder](https://www.arhohuttunen.com/test-data-builders/)
- 방법2. 픽스처 프레임워크를 활용해본다
    - **Instancio**
        - fixture가 간단한 경우 사용하기 좋다함
        - 참고. [https://www.instancio.org/](https://www.instancio.org/)
    - **fixture monkey** : naver 오픈소스
        - 유연성은 좋은데 가독성은 아쉽다함
        - 복잡한 테스트 fixture를 만들 때 사용
        - 러닝 커브 존재
        - 참고. [https://naver.github.io/fixture-monkey/v1-1-0/](https://naver.github.io/fixture-monkey/v1-1-0/)

<br/>

**도서 추천**
- [테스트 주도 개발](https://www.yes24.com/Product/Goods/12246033)
- [레거시 코드 활용 전략](https://www.yes24.com/Product/goods/64586851)
- [이펙티브 유닛 테스팅](https://www.yes24.com/Product/Goods/11361087)

---
## 학습 기록

**목차**
- [4.1 자가 테스트 코드의 가치](#41-자가-테스트-코드의-가치)
- [4.2 테스트할 샘플 코드](#42-테스트할-샘플-코드)
- [4.3 첫 번째 테스트](#43-첫-번째-테스트)
- [4.4 테스트 추가하기](#44-테스트-추가하기)
- [4.5 픽스처 수정하기](#45-픽스처-수정하기)
- [4.6 경계 조건 검사하기](#46-경계-조건-검사하기)
- [4.7 끝나지 않은 여정](#47-끝나지-않은-여정)


### 4.1 자가 테스트 코드의 가치

> 모든 테스트를 완전히 자동화하고 그 결과까지 스스로 검사하게 만들자

**테스트를 작성했을 때 장점**
- 컴파일할 때마다 테스트도 함께 실행하면서 디버깅 시간이 크게 줄어든다 (생산성 향상에도 영향)
  - 이때 가장 최근 테스트로 잡은 버그를 다시 살려보면 테스트에 걸려 눈에 확 들어난다
  - (좋은 습관👍) 실패해야 할 상황에서 반드시 실패하게 만들자
- 직전까지 테스트가 성공했다면 마지막 테스트 이후에 작성한 코드에서 버그가 발생했음을 알 수 있음
  - 테스르를 몇분 간격으로 자주 수행할 경우 버그가 발생한 지점이 조금 전에 작성한 코드에 있다는 사실을 쉽게 파악할 수 있다.
  - 의심되는 코드의 양이 많지 않기 때문에, 버그를 쉽게 찾을 수 있다.
<br/>

**회귀 버그🐞(regression bug)**
- 잘 동작하던 기능에서 문제가 생기는 현상을 가르킴
- 일반적으로 프로그램을 변경하는 중 뜻하지 않게 발생한다
- 같은 맥락에서, 잘 작동하던 기능이 여전히 잘 작동하는지 확인하는 테스트를 **회귀 테스트(regression test)** 라 한다
<br/>

> **NOTE** <br/>
> (p135) 테스트가 실제로 프로그래밍 속도를 높여주는 경험을 직접 해보지 않고서는 자가 테스트의 진가를 납득하기 어렵다. 게다가 테스트 작성법을 배운 적이 없는 프로그래머가 많을뿐더러, 테스트에 대해 생각조차 못 해본 이도 많다.
테스트를 수동으로 하면 좀이 쑤실 정도로 지겹다. 하지만 자동화한다면 테스트 코드를 작성하는 재미가 꽤 쏠쏠하다.
<br/>

> **NOTE** 테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다. <br/>
> 나는 기능을 추가해야할 때 테스트부터 작성한다. (..) 테스트를 작성하다보면 원하는 기능을 추가하기 위해 무엇이 필요한지 고민하게 된다. 구현보다 인터페이스에 집중하게 된다는 장점도 있다(무조건 좋은 일이다)
게다가 코딩이 완료되는 시점을 정확하게 판단할 수 있다. 테스트를 모두 통과한 시점이 바로 코드를 완성한 시점이다.
<br/>

> **NOTE** 
> 리팩터링하기 가장 좋은 시점은 코드 베이스에 기능을 새로 추가하기 직전이다.<br/>
> 이 시점에 현재 코드를 살펴보면서 구조를 살짝 바꾸면 다른 작업을 하기 훨씬 쉬워질 만한 부분을 찾는다. - Chapter02
<br/>

**테스트 주도 개발(TDD)**
- 테스트부터 작성하는 습관을 바탕으로 기법을 창시 (by 켄트 벡)
- TDD는 `red-green-blud` 사이클을 반복
  - 테스트를 먼저 작성(red) ➡️ 테스트를 통과하게끔 코드 작성(green) ➡️ 결과 코드를 최대한 깔끔하게 리팩터링(blue)
- 이 과정을 한 시간에도 여러 차례 진행하기 때문에 코드를 대단히 생산적이면서도 차분하게 작성할 수 있다

<br/>

### 4.2 테스트할 샘플 코드

예시는 사용자가 생산 계획을 검토하고 수정하도록 해주는 간단한 애플리케이션의 일부이다.

<img src="https://github.com/ljw1126/user-content/blob/master/refactoring2/ch04/example.png?raw=true">
<br/>

**요구사항**
- 생산 계획은 각 `지역(province)`, `수요(demand)`, `가격(price)`
- 지역에 위치한 `생산자(producer)`들은 각기 제품을 특정 가격으로 특정 수량만큼 생산할 수 있다
- UI는 생산자별로 제품을 모두 판매했을 때 얻을 수 있는 `수익(full revenue)`도 보여준다
- 화면 맨 아래에는 `생산 부족분(shortfall = 수요 - 총 생산량)`과 현재 계획에서 거둘 수 있는 `총수익(profit)`도 보여준다
- 사용자는 UI에서 `수요`, `가격`, `생산자별 생산량(production)`과 `비용(cost)`을 조정해가며, 그에 따른 `생산 부족분`과 `총수익`을 확인할 수 있다.
- 사용자가 화면에서 숫자를 변경할 때마다 관련 값들이 즉각 갱신된다.
- 비즈니스 로직 코드는 클래스 두 개로 구성된다
  - `Producer` : 생산자를 표현
  - `Province` : 지역 전체를 표현
    - 이때 `Province`의 생성자는 JSON 문서로부터 만들어진 자바스크립트 객체를 인수로 받는다

<br/>

### 4.3 첫 번째 테스트

> 실패해야 할 상황에서 반드시 실패하게 만들자

> 자주 테스트하라. 작성 중인 코드는 최소한 몇 분 간격으로 테스트하고, 적어도 하루에 한 번은 전체 테스트를 돌려보자.

<br/>

**참고.**
- 도서에서는 JavaScript로 예제 작성
- `모카 프레임워크` : 소위 어서션 라이브러리라고 하는 픽스처 검증 라이브러리 소개
- `차이 라이브러리` 사용 (JavaScript Assertion 라이브러리 중 하나) 

<br/>

### 4.4 테스트 추가하기

> 완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는 게 낫다

**명심하자! 테스트는 ⚠️위험 요인을 중심으로 작성해야 한다**
- 테스트의 목적은 어디까지나 현재 혹은 향후에 발생하는 버그를 찾는데 있다.
- 따라서 단순히 필드를 읽고 쓰기만 하는 접근자는 테스트할 필요 ❌(ex. getter, setter)
- 테스트를 너무 많이 만들다 보면 오히려 필요한 테스트를 놓치기 쉽다 (⚠️주의)

**권장 방법**
- 기존 코드를 검사할 때
  - 임시 값을 설정했다가 실제 값으로 대체하고, 오류를 심었다가 되돌린다 👍
- 테스트끼리 상호작용하게 하는 공유 픽스처 생성할 경우
  - `beforeEach()` 초기화 하는 방법 선호 👍
  - 개별 테스트 실행할 때마다 픽스처를 새로 만들면 모든 테스트를 독립적으로 구성할 수 있다
  - 이를 통해 결과를 예측할 수 없어 골치를 썩는 사태를 예방할 수 있다. (테스트별 독립성 보장)


<br/>

### 4.5 픽스처 수정하기
- 테스트 픽스처를 매 테스트마다 생성, 테스트마다 독립성 보장
- 테스트를 `수행`하고, 이 픽스처가 일을 기대한 대로 처리했는지 `검증`한다
  - 이 패턴을 `설정-실행-검증(setup-exercise-verify), 조건-발생-결과(given-when-then), 준비-수행-단언(arragne-act-assert)` 등으로 부른다
<br/>

> **INFO** <br/>
> (..) beforeEach에서 수행하도록 작성해두면 테스트들 사이에 걸친 픽스처를 테스트 프레임워크가 알아서 해체해주기 때문에 굳이 단계를 나눌 필요는 없다. (..) 그런데 드물지만 해체를 명시적으로 수행해야 할 때가 있다. 특히 생성하는 데 시간이 걸려서 여러 테스트가 공유해야만 하는 픽스처가 여기 해당한다.

<br/>

### 4.6 경계 조건 검사하기

> 문제가 생길 가능성이 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자

**경계 조건 예시**
- 생산자가 없는 경우(컬렉션 사이즈가 `0`)
- 수요(demand)가 음수 값인 경우
- 수요(demand)에 필드가 문자열("")이 주어지는 경우 
- 생산자 수(producers, 컬렉션) 필드에 문자열("")을 대입하는 경우
<br/>

> **INFO** <br/>
> **실패(failure)**: 검증 단계에서 실제 값이 예상 범위를 벗어났다는 뜻이다. <br/>
> **에러(error)**: 검증보다 앞선 과정에서 발생한 예외 상황을 말한다. (성격이 다름)
<br/>

**1️⃣ 유효성 검사 중복 문제**
- 같은 코드 베이스의 여러 모듈에서 유효성 검사를 너무 많이 하면 이미 검증된 값을 또 검증하는 문제가 발생할 수 있음.
- 하지만 **외부에서 들어온 데이터(JSON 요청 등)** 는 신뢰할 수 없기 때문에 반드시 유효성 검사를 해야 하며, 이에 대한 테스트도 작성해야 함.
- 즉, 내부 모듈 간에는 중복 검증을 피해야 하지만, 외부 입력은 신뢰할 수 없으므로 반드시 검증해야 한다.
<br/>

**2️⃣ "나는 리팩터링하기 전이라면 이런 테스트를 작성하지 않을 것이다." 이유**
- 리팩터링 과정에서는 경계 조건 테스트를 새로 추가하지 않는다는 뜻
- 리팩터링은 **"겉보기 동작을 바꾸지 않고 코드 구조를 개선하는 것"** 이므로,
- 경계 조건 검사는 기능 동작을 바꾸는 부분이지, 단순 리팩터링 대상이 아님.
- 따라서 리팩터링을 하면서 새로운 경계 조건 테스트를 작성할 필요는 없음.
- 즉, 리팩터링 과정에서는 기존 동작을 유지하는 것이 목표이므로, 새로운 검증 테스트를 추가하지 않는다.
<br/>

```text
[요약]
📌 경계 조건 테스트는 새로운 기능을 추가할 때 작성해야 한다.
📌 리팩터링은 기존 기능을 변경하지 않고 코드 구조를 개선하는 것이므로, 경계 조건 테스트를 새로 추가하지 않는다.
즉, 기능을 추가할 때는 경계 조건을 고려해서 테스트를 작성해야 하지만, 리팩터링할 때는 기존 테스트를 유지하면서 코드 구조만 개선하는 것이 원칙!
```
<br/>

> 어차피 모든 버그를 잡아낼 수는 없다고 생각하여 테스트를 작성하지 않는다면 대다수의 버그를 잡을 수 있는 기회를 날리는 셈이다.
<br/>

**테스트에도 수확 체감 법칙이 적용된다**
- 테스트를 너무 많이 작성하다 보면 오히려 의욕이 떨어져 나중에는 하나도 작성하지 않게 될 위험도 있다
- 따라서 위엄한 부분에 집중하는 게 좋다.
- 코드에서 처리 과정이 복잡한 부분을 찾아보자
- 함수에서 오류가 생길만한 부분을 찾아보자
<br/>

<u>테스트가 모든 버그를 걸러주지는 못할지라도, 안심하고 리팩터링할 수 있는 보호막은 되어준다. 
그리고 리팩터링을 하면서 프로그램을 더욱 깊이 이해하게 되어 더 많은 버그를 찾게 된다. </u>


### 4.7 끝나지 않은 여정

> 단위 테스트(unit test): 코드의 작은 영역만을 대상으로 빠르게 실행되도록 설계된 테스트다.

- 기능을 새로 추가할 때마다 테스트도 추가하는 것은 물론, 기존 테스트도 다시 살펴본다
  - 기존 테스트가 충분히 명확한지
  - 테스트 과정을 더 이해하기 쉽게 리팩터링할 수 없는지
  - 제대로 검사하는지 등등
- 버그 리포트를 받으면 가장 먼저 그 버그를 드러내는 단위 테스트부터 작성하는 습관을 들이자


테스트 커버리지 분석은 코드에서 테스트하지 않은 영역을 찾는 데만 도움될 뿐, 테스트 스위트의 품질과는 크게 상관없다. 테스트 스위트가 충분한지를 평가하는 기준은 주관적이다.

<u>테스트 때문에 개발 속도가 느려진다고 생각되면 테스트를 과하게 작성한 건 아닌지 의심해보자.
하지만 너무 많은 경우보다는 너무 적은 경우가 훨씬 훨씬 많다</u>

---
## 찾아보기
- 자바 dto vs record : https://yozm.wishket.com/magazine/detail/2814/
- (naver) fixture-monkey: https://github.com/naver/fixture-monkey?tab=readme-ov-file
- test fixture plugin: https://toss.tech/article/how-to-manage-test-dependency-in-gradle
- stream에서 가변 변수를 사용할 경우 문제
  - [Java 스트림(Stream)에서 가변 변수 사용 시 발생하는 문제 및 해결 방법](https://curiousjinan.tistory.com/entry/java-stream-mutable-variable-issues)
  - 우회하는 방식도 있으나, 함수형 프로그래밍의 핵심 원치인 불변성과 순수 함수의 이점을 저해한다
  - 결과적으로 가변 변수를 사용하면 스트림의 설계 철학에 어긋나며, 스트림의 강력한 기능을 온전히 사용하기 어렵다.
    - 동시성 문제(자원 경합), 예측 불가능한 동작, 가독성 및 유지보수성 저하 등
