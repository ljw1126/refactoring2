# Chapter2. 리팩터링 원칙

> "난 뛰어난 프로그래머가 아니에요 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요" - 켄트벡

## 후기

이번 챕터에서 두 가지가 특히 기억에 남는다.
<br/>

첫 번째로 '기능 추가 모자'와 '리팩터링 모자'라는 비유가 인상 깊었다. 
작업할 때 모자를 바꿔 쓰며 각자의 목적에 집중해야 한다는 의미인데, 실제 실무에서는 두 모자를 동시에 쓰기도 했던 거 같다.
예를 들어, 리팩터링을 하다가 기능 추가를 하기도 했는데, 이에 따라 작업이 꼬이기도 하고 커밋 이력이 복잡해졌던 기억이 난다.
이번 기회에 반성하며, 앞으로 목적에 맞게 작업을 분리하고 명확한 기준을 세워 집중해야겠다고 다짐했다.
<br/>

```text
1. 기능 추가 모자 🧢: 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다 
2. 리팩터링 모자 🎩: 기능 추가는 절대 하지 않기로 다짐, 오로지 코드 재구성에만 전념한다
```

두 번째로 "**리팩터링한다고 말하지 말라**"는 저자의 조언이 뇌리에 남았다. 
**우리는 프로 개발자이고, 우리에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이다.** 
그러기 위해 리팩터링과 테스트를 자연스럽게 활용하면서 코드 품질을 유지해야 한다.
저자는 리팩터링을 하나의 '추가 작업'처럼 인식하기보다, 개발 과정에서 당연히 함께 수행해야 할 습관으로 만들 것을 강조하는 듯했다.
실무에서 '리팩터링 일정'을 따로 요청했던 기억이 난다. 
코드 품질에 관심 없던 팀장, 고객에게 리팩터링을 직접 언급하는 대신, 자연스럽게 필요한 시점에 수행했다면 어땠을까하는 생각이 든다.
<br/>

테스트 체계화가 되어있는 나의 현 상황에서 리팩터링 기준을 세우고, 기법을 익힌다면 얼마나 더 성장할 수 있을지 앞으로가 기대된다. 

---
## 스터디 요약 (2/6 목요일)
- 리팩터링을 '클린 코드'나 '바람직한 엔지니어 습관'처럼 도덕적 이유로 정당화 x
  - 우월감이나 자기 과시욕은 👎
  - 급해서 빨리 쳐내다보면 기술 부채 발생 ➡️부채는 갚아야 한다 ➡️부채를 갚는 빠른 방법은 **리팩터링**이다
  - 회사 서비스의 이슈 또는 기술 부채와 연관지어서 리팩토링의 필요성을 말하는 건 👍
- '리팩터링 한다고 말하지말라'
  - 관계자, 고객은 코드 퀄리티에 관심이 없을 수 있다
  - <u>리팩터링 일정이 필요하다고 하면 **대충 일한다는 인상**을 줄 수 있다</u>
  - (내 생각) 기능 구현을 우선으로 하되, 리팩터링까지 포함해서 일정을 잡도록 하자
- 커밋 단위
  - 국소적 리팩토링을 수행하여 테스트가 통과한다면 커밋을 묶어도 괜찮다
  - 하지만 공통 사용하는 코어단이나 큰 거는 충돌 위험도 있어 작업 분리할 필요가 있다
- '말로 표현할 수 있는 코드, 읽기 편한 코드가 좋은 코드이다'
- 리팩터링과 성능 관련
  - '인터넷에 성능 관련된 얘기, 블로그 글 대부분 헛소리' (객관적 지표 비교도 없는 뇌피셜은 믿으면 안됨)
  - 과거와 달리 메서드 분리한다고해서 성능 이슈가 발생하진 않는다
  - 개발자 생산성이 s/w 성능보다 더 중요하다
  - <u>개발자의 생산성을 향상시키는 방법은 역시 '**리팩터링**'이다</u>
- 리팩터링을 하지 말아야 할 때
  - 시간만 잡아먹고 팀에 도움이 되지 않는 것은 하지 않는다
  - 테스트가 없는 리팩터링은 오래 걸리지 때문에 하지 않는게 나을수도 있다
  - **YAGNI** (너 그거 지금 필요 없어! 오버 엔지니어링하지 않기)


---
## 학습 기록

**목차**
- [2.1 리팩터링 정의](#21-리팩터링-정의)
- [2.2 두 개의 모자](#22-두-개의-모자)
- [2.3 리팩터링 하는 이유](#23-리팩터링-하는-이유)
- [2.4 언제 리팩터링 해야 할까?](#24-언제-리팩터링-해야-할까)
- [2.5 리팩터링 시 고려할 문제](#25-리팩터링-시-고려할-문제)
- [2.6 리팩터링, 아키텍처, 애그니(YAGNI)](#26-리팩터링-아키텍처-애그니yagni)
- [2.7 리팩터링과 소프트웨어 개발 프로세스](#27-리팩터링과-소프트웨어-개발-프로세스)
- [2.8 리팩터링과 성능](#28-리팩터링과-성능)


### 2.1 리팩터링 정의

> 리팩터링(명사):
> s/w의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

> 리팩터링(동사):
> s/w의 겉보기 동작은 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 s/w를 재구성하다

리팩터링은 
- 동작을 보존하며 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다
- 재구성 중 특수한 한 형태로 본다
- 하나의 작업을 여러 단계로 나누는 것이 비효율적으로 보일 수 있다. 하지만 잘게 나눔으로써 오히려 작업을 더 빨리 처리할 수 있다
  - 목적에 따라 분리함으로써 코드 가독성 향상과 테스트 용이해진다
  - 그리고 생산성 향상된다

```text
'리팩터링'과 '성능 최적화'의 차이
- 리팩터링: 코드를 이해하고 수정하기 쉽게 만드는 것이다
- 성능 최적화: 오로지 속도 개선에만 신경쓴다. 그러다보니 코드가 더 어렵게 바뀔 수 있다.
```

<br/>

### 2.2 두 개의 모자
켄트벡은 s/w를 개발할 때 목적을 두 개의 모자에 비유했다
```text
1. 기능 추가 모자 🧢: 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다 
2. 리팩터링 모자 🎩: 기능 추가는 절대 하지 않기로 다짐, 오로지 코드 재구성에만 전념한다
```

<img src="https://github.com/ljw1126/user-content/blob/master/refactoring2/ch02/two%20hat.jpeg?raw=true" width="500" height="500">

<br/>

### 2.3 리팩터링 하는 이유

> 리팩터링이 s/w의 모든 문제점을 해결하는 만병통치약은 절대 아니다. 
> 하지만 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다.
> 결국 리팩터링도 도구⚒️이다.

1. s/w 설계가 좋아진다
- 같은 일을 하더라도 설계가 나쁘면 코드가 길어지기 쉽다.
- 코드가 길수록 실수 없이 수정하기 어렵다
- 이해해야 할 코드량이 늘어난다
- 중복 코드가 발생하고 결국 유지보수 문제가 발생가능하다
- 리팩터링을 통해 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있다.

2. s/w를 이해하기 쉬워진다 (= 가독성 향상)
- 프로그램을 동작시키는데만 신경 쓰다보면 나중에 그 코드를 다룰 개발자(타인, 자신)를 배려하지 못한다. 
- 코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화를 줘야 한다.
- 리팩터링은 코드가 더 잘 읽히게 도와준다. 

3. 버그🐞를 쉽게 찾을 수 있다 (= 유지보수 용이)
- 리팩터링을 하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것은 곧바로 코드에 반영하게 된다.
- 리팩터링은 견고한 코드를 작성하는데 무척 효과적이다.

4. 프로그래밍 속도를 높일 수 있다 (= 비용 감소, 생산성 향상)
- 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 풀질 향상에 직결된다
- 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.
- 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다
- 코드가 명확하면 버그를 만들 가능성이 준다
- 버그를 만들더라도 디버깅이 쉽다
- 내부 품질이 뛰어난 코드 베이스는 새 기능 구축을 돕는 견고한 토대가 된다

<br/>

### 2.4 언제 리팩터링 해야 할까?

> **3의 법칙** (돈 로버츠)
> 1. 처음에는 그냥 한다
> 2. 비슷한 일을 두 번째로 하게 되면(=중복 발생), 일단 계속 진행한다
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링 한다

<br/>

**준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**
- 코드 베이스에 새 기능을 추가 하기 직전, 현재 코드 구조를 변경했을 때 다른 작업을 하기 훨씬 쉬워질 만한 부분을 찾는다
- 버그를 잡을때도 마찬가지로, 코드가 세 곳에 퍼져있다면 우선 한 곳으로 합치는 편이 훨씬 작업하기 편하다.
- 또는 질의 코드(query)에 섞여 있는 갱신 로직(command)를 분리하면 두 작업이 꼬여서 생기는 오류를 크게 줄 일 수 있다

<br/>

**이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**
- 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다. (ex. 조건부 로직, 함수명)
- 어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고, 긴 함수를 잘게 나누기도 한다
- 이를 통해 코드가 정리되면 전에는 보이지 않던 설계가 눈에 들어오기 시작한다

> 랄프 존슨은 이런 초기 단계의 리팩터링을 밖을 잘 내다보기 위한 "창문 닦기🪟"에 비유한다. <br/> 
> 코드를 분석할때 리팩터링을 해보면, 그렇지 않더라도 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

<br/>

**쓰레기 줍기 리팩터링**
- 간단히 수정할 수 잇는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.
- 캠핑 규칙이 제안하듯, 항상 처음 왔을 때 보다 깔끔하게 정리하고 떠나자. 
- 코드를 훓어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것이다.

<br/>

**계획된 리팩터링과 수시로 하는 리팩터링**
- 프로그래밍 과정에 리팩터링을 자연스럽게 녹인다.
- 리팩터링 시간을 일정에 따로 잡아두지 않고, 대부분의 리팩터링을 다른 일을 하는 중에 처리한다.
- <u>예컨대 매개변수화하거나 개별 함수로 나누는 기준을 정한다.</u> 
- 어제는 적합했던 기준이 오늘 하는 다른 작업에는 맞지 않을 수 있다. 
- 이렇게 상황이 변해 기준을 변경해야 할 때 코드가 이미 깔끔하다면 리팩터링 하기가 더 쉽다.

> **좋은 글** <br/>
> 오랫동안 사람들은 소프트웨어 개발이란 뭔가 "추가"하는 과정으로 여겼다. <br/> 
> 하지만 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 "수정"하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음을 안다. <br/> 
> 소프트웨어 개발을 끝이 있는 작업으로 보면 안된다. <br/>
> 새 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정된다.

<br/>

**오래 걸리는 리팩터링**
- 팀 전체가 대규모 리팩터링에 매달리는 것보다, 주어진 문제를 몇 주에 걸쳐 조금씩 해결하는 편이 효과적이다.
- <u>리팩터링이 코드를 꺠뜨리지 않는다는 장점을 활용하는 것이다.</u>
- <u>일부를 변경해도 모든 기능이 항상 올바르게 동작한다.</u>

> 지속적인 CI도 필요할 것으로 생각된다.

<br/>

**코드 리뷰에 리팩터링 활용하기**
- 리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는데에 도움이된다.
- 개선안을 제시하는데서 그치지 않고, 그 중 상당수를 즉시 구현해 볼 수 있기 때문이다.
- 코드 리뷰를 하면 다른 사람의 아이디어를 얻을 수 있따는 장점도 있다.

> 물론 테스트 코드가 기반이 되야 한다

<br/>

**관리자에게는 뭐라고 말해야 할까?**
- 기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다
- 이런 상황에 있는 이에게 <u>"리팩터링한다고 말하지 말라"</u>고 조언한다
- 일정을 최우선으로 여기는 관리자는 최대한 빨리 끝내는 방향으로 진행하기를 원한다. 구체적인 방법은 개발자가 판단해야 한다 (😂)
- 이때도 리팩터링 부터 하는 편이 가장 빠르다.
- <u>프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다.</u>

<br/>

**리팩터링하지 말아야 할 때**
- 외부 API 다루듯 호출해서 쓰는 코드라면 지저분 해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩터링 해야 효과를 제대로 볼 수 있다.
- 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.

<br/>

### 2.5 리팩터링 시 고려할 문제

**새 기능 개발 속도 저하**
- 새 기능을 구현해 넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않고 리팩터링부터 한다.
- 반면 직접 건드릴 일이 거의 없거나, 불편한 정도가 심하지 않거나, 어떻게 개선해야 할지 확실히 떠오르지 않을떄는 미룬다.
- 가장 빠지기 쉬운 위험한 오류는 <u>리팩터링을 '클린 코드'나 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는 것이다.</u>
- **리팩터링은 오로지 경제적인 이유로 하는 것이다**

<br/>

**테스팅**
- 테스트를 통해 리팩터링 과정에서 발생 가능한 불안감을 해소할 수 있다.
- IDE에서 제공하는 리팩터링 기능을 활용하면 테스트 없이도 리팩터링 가능하다.

<br/>

**레거시 코드** <br/>
레거시 시스템을 파악할 때 리팩터링이 굉장히 도움이 된다. (<u>탄탄한 테스트가 뒷받쳐 줘야 한다</u>)
<br/>
테스트를 갖추고 있더라도 복잡하게 얽힌 레거시 코드를 아름다운 코드로 단번에 리팩터링하는 데는 낙관적이지 않다. 
내가 선호하는 방식은 서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이다. (..) 
레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다. 
코드를 훓게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이니 당연히 이렇게 해야 한다.

<br/>

**데이터베이스** <br/>
데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다. 이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다
<br/>

예로 필드 이름을 바꿀 때
- 첫 번쨰 커밋에서는 새로운 데이터베이스 필드를 추가만 하고 사용하지 x
- 기존 필드와 새 필드를 동시에 업데이트 하도록 설정
- 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다
- 이 과정에서 발생하는 버그도 해결하면서 클라이언트 교체 작업은 모두 끝낸다면, 예전 필드를 삭제한다

이렇게 데이터베이스를 변경하는 방식은 **병렬 수정(또는 팽창 수축)** 의 일반적인 예다

<br/>

### 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

> 완벽한 설계는 없고, 모든 요구사항을 사전에 파악하여 설계하는 것은 불가능하다

(p101)<br/>
리팩터링을 활용하면 다르게 접근할 수 있다. 
앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 
단, 이 요구를 멋지게 해결하도록 설계한다.
<br/><br/>
예상되는 변경을 미리 반영하는 리팩터링을 미루면 나중에 얼마나 어려워질지를 가늠해보면 판단에 도움될 때가 많다. 
리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 유연성 메커니즘을 미리 추가한다.
<br/><br/>
이런 식으로 설계하는 방식을 간결한 설계, 점진적 설계, **YAGNI(you arent going to need it의 줄일말)** 등으로 부른다

<br/>

### 2.7 리팩터링과 소프트웨어 개발 프로세스
- TDD (테스트 주도 개발) = 자가 테스트 코드 + 리팩터링
- 지속적 통합(CI)을 적극 권장 
  - 지속적 통합을 적용하면 팀원 각자가 수행한 결과를 빠르게 동료와 공유할 수 있다
- 자가 테스트 코드 역시 지속적 통합의 핵심 요소이다
- 따라서 <u>자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법은 서로 강력한 상승 효과를 발휘한다.</u>

<br/>

### 2.8 리팩터링과 성능
(p105)<br/>
<u>성능에 대한 흥미로운 사실은 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것이다. 
</u>그래서 코드 전체를 고르게 최적화한다면 그 중 90%는 효과가 거의 없기 때문에 시간 낭비인 셈이다. 
속도를 높이기 위해 투자한 시간을 모두 날리는 행위다.

성능 개선을 위한 세번째 방법은 이 '90%의 시간은 낭비'라는 통계에서 착안한 것이다. 
즉 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다. 
그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다.
```text
① 프로파일러로 프로그램을 분석하여 병목(시간, 공간) 지점 찾는다.  
② 성능에 큰 영향을 주는 부분만 집중해서 최적화하기 때문에 적은 노력으로 훨씬 큰 효과를 볼 수 있다.
③ 최적화할때 리팩터팅처럼 작은 단계로 나눠서 진행한다.
④ 각 단계마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본다.
⑤ 성능이 개선되지 않았다면 수정 내용을 롤백한다.
```

리팩터링을 잘 해두면 성능 최적화할 때 도움이 된다
```text
① 성능 튜닝에 투입할 시간을 확보할 수 있다
② 리팩터링이 잘 되어 있는 프로그램은 프로파일러 통해 성능을 더 세밀하게 분석할 수 있다.
-> 결국 범위가 더 좁아지고, 더 튜닝하기 쉬워진다.
```

결과적으로
<u>리팩터링은 성능 좋은 소프트웨어를 만드는데 기여한다. 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수 있다. 하지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬워지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다</u>


---
## Reference.
- [설계 지구력 가설](https://martinfowler.com/bliki/DesignStaminaHypothesis.html)
- [Refactoring Workbook](https://www.informit.com/store/refactoring-workbook-9780321109293)

